diff --git a/apt-pkg/algorithms.cc b/apt-pkg/algorithms.cc
index 1b8b73f..ca03bd1 100644
--- a/apt-pkg/algorithms.cc
+++ b/apt-pkg/algorithms.cc
@@ -739,6 +739,7 @@ bool pkgProblemResolver::DoUpgrade(pkgCache::PkgIterator Pkg)
       clog << "  Re-Instated " << Pkg.Name() << endl;
    return true;
 }
+#include <stdio.h>
 									/*}}}*/
 // ProblemResolver::Resolve - Run the resolution pass			/*{{{*/
 // ---------------------------------------------------------------------
@@ -830,7 +831,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 	     (Flags[I->ID] & PreInstalled) != 0 &&
 	     (Flags[I->ID] & Protected) == 0 &&
 	     (Flags[I->ID] & ReInstateTried) == 0)
-	 {
+         {
 	    if (Debug == true)
 	       clog << " Try to Re-Instate " << I.Name() << endl;
 	    unsigned long OldBreaks = Cache.BrokenCount();
@@ -841,8 +842,8 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 	    if (Cache[I].InstBroken() == true || 
 		OldBreaks < Cache.BrokenCount())
 	    {
-	       if (OldVer == 0)
-		  Cache.MarkDelete(I);
+               if (OldVer == 0){
+                  Cache.MarkDelete(I);}
 	       else
 		  Cache.MarkKeep(I);
 	    }	    
@@ -868,7 +869,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 	 enum {OrRemove,OrKeep} OrOp = OrRemove;
 	 for (pkgCache::DepIterator D = Cache[I].InstVerIter(Cache).DependsList();
 	      D.end() == false || InOr == true;)
-	 {
+         {
 	    // Compute a single dependency element (glob or)
 	    if (Start == End)
 	    {
@@ -881,7 +882,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 		     {
 			if (Debug == true)
 			   clog << "  Or group remove for " << I.Name() << endl;
-			Cache.MarkDelete(I);
+                        Cache.MarkDelete(I);
 			Change = true;
 		     }		     
 		  }		  
@@ -922,6 +923,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 	    if (Debug == true)
 	       clog << "Package " << I.Name() << " has broken dep on " << Start.TargetPkg().Name() << endl;
 
+
 	    /* Look across the version list. If there are no possible
 	       targets then we keep the package and bail. This is necessary
 	       if a package has a dep on another package that cant be found */
@@ -941,7 +943,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 	       Change = true;
 	       Cache.MarkKeep(I);		  
 	       break;
-	    }
+            }
 	    
 	    bool Done = false;
 	    for (pkgCache::Version **V = VList; *V != 0; V++)
@@ -953,6 +955,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 		  clog << "  Considering " << Pkg.Name() << ' ' << (int)Scores[Pkg->ID] <<
 		  " as a solution to " << I.Name() << ' ' << (int)Scores[I->ID] << endl;
 
+
 	       /* Try to fix the package under consideration rather than
 	          fiddle with the VList package */
 	       if (Scores[I->ID] <= Scores[Pkg->ID] ||
@@ -978,6 +981,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 		     then installing it will be necessary */
 		  bool Installed = Cache[I].Install();
 		  Cache.MarkKeep(I);
+
 		  if (Cache[I].InstBroken() == false)
 		  {
 		     // Unwind operation will be keep now
@@ -1000,7 +1004,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 			{
 			   if (Debug == true)
 			      clog << "  Removing " << I.Name() << " rather than change " << Start.TargetPkg().Name() << endl;
-			   Cache.MarkDelete(I);
+                           Cache.MarkDelete(I);
 			   if (Counter > 1)
 			   {
 			      if (Scores[Pkg->ID] > Scores[I->ID])
@@ -1070,7 +1074,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 	    {
 	       bool Installed = Cache[I].Install();
 	       Cache.MarkKeep(I);
-	       if (Cache[I].InstBroken() == false)
+               if (Cache[I].InstBroken() == false)
 	       {
 		  // Unwind operation will be keep now
 		  if (OrOp == OrRemove)
@@ -1087,8 +1091,10 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 	       {
 		  if (Debug == true)
 		     clog << "  Removing " << I.Name() << " because I can't find " << Start.TargetPkg().Name() << endl;
-		  if (InOr == false)
-		     Cache.MarkDelete(I);
+                  if (InOr == false) {
+
+                     Cache.MarkDelete(I);
+                  }
 	       }
 
 	       Change = true;
@@ -1116,7 +1122,7 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
 		  {
 		     if (Debug == true)
 			clog << "  Fixing " << I.Name() << " via remove of " << J->Pkg.Name() << endl;
-		     Cache.MarkDelete(J->Pkg);
+                     Cache.MarkDelete(J->Pkg);printf("\ntrace:%s,%d,mark[%s]\n",__FUNCTION__,__LINE__,J->Pkg.Name());
 		  }
 	       }
 	       else
@@ -1155,6 +1161,369 @@ bool pkgProblemResolver::Resolve(bool BrokenFix)
    
    return true;
 }
+static pkgDepCache *g_Cache =NULL;
+static pkgDepCache *g_CacheIsoft = NULL;
+bool CheckPkgInCachex(pkgDepCache &Cache,const char *pkgName,bool reCheck)
+{
+     bool result = false;
+    for (pkgCache::PkgIterator Pkg = Cache.PkgBegin();
+         Pkg.end() == false; Pkg++)
+    {
+        if (strcmp(Pkg.Name(),pkgName) !=0)
+            continue;
+#if 0
+        //if(strcmp(pkgName,"librevenge") ==0)
+        printf("\ntrace:%s,%d,will check[%s]c[%x]s[%x]verlist[%x]||np[%x]revdep[%x],povlist[%x].count[%d][%s]\n",__FUNCTION__,__LINE__,
+                       pkgName,Pkg->CurrentVer,Pkg->Section,Pkg->VersionList,
+                       Pkg->NextPackage,Pkg->RevDepends,Pkg->ProvidesList,Cache.Head().PackageCount,reCheck?"re":"not re");
+#endif//
+        // only check in isoft
+        if (!reCheck) {
+            if (Pkg->CurrentVer != 0) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+        // to check in sys
+        // no.1 cur && pre, maybe in sys
+        if (Pkg->RevDepends != 0 && Pkg->ProvidesList != 0) {
+            result = true;
+            const char *p = strstr(pkgName,"(");
+            if (p == NULL) {
+                if (Pkg->VersionList == 0) {
+                    return true;
+                } else if (Pkg->CurrentVer != 0) {
+                    return true;
+                } else {
+                    return false;
+                }
+            } else {
+                bool find = false;
+                char newPkg[512]="";
+                snprintf(newPkg,p-pkgName +1,"%s",pkgName);
+                //printf("\ntrace:%s,%d,will check new pkg[%s].\n",__FUNCTION__,__LINE__,newPkg);
+
+                for (pkgCache::PkgIterator PkgSys = Cache.PkgBegin();
+                     PkgSys.end() == false; PkgSys++)
+                {
+                    if (strcmp(PkgSys.Name(),newPkg) !=0)
+                        continue;
+#if 0
+                    //if(strcmp(pkgName,"librevenge") ==0)
+                    printf("\ntrace:%s,%d,will check[%s]c[%x]s[%x]verlist[%x]||np[%x]revdep[%x],povlist[%x].\n",__FUNCTION__,__LINE__,
+                                   newPkg,PkgSys->CurrentVer,PkgSys->Section,PkgSys->VersionList,
+                                   PkgSys->NextPackage,PkgSys->RevDepends,PkgSys->ProvidesList);
+#endif
+                    if (PkgSys->CurrentVer == 0) {
+                        //printf("\ntrace:%s,%d.pkg[%s] not installed\n",__FUNCTION__,__LINE__,newPkg);
+                        return false;
+                    }if (PkgSys->RevDepends != 0 && PkgSys->ProvidesList != 0) {
+                        return true;
+                    } else if (PkgSys->RevDepends == 0) {
+                        return false;
+                    } else {
+                        printf("\ntrace:%s,%d,pkg[%s],never go here!\n",__FUNCTION__,__LINE__,newPkg);
+                        return false;
+                    }
+                }
+                // can not find newpkg in sys, just return;
+                if (!find) {
+                    return true;
+                }
+
+            }
+        } else if (Pkg->RevDepends == 0) {
+            return false;
+        } else {
+            printf("\ntrace:%s,%d,pkg[%s],never go here!\n",__FUNCTION__,__LINE__,pkgName);
+            return false;
+        }
+    }
+
+    //printf("\ntrace:%s,%d,end.can not find pkg[%s]\n",__FUNCTION__,__LINE__,pkgName);
+
+    return result;
+}
+bool getPkgInstallStatex(pkgDepCache &Cache,pkgDepCache &CacheIsoft,const char *pkgName)
+{
+    //char pkgName[512]="";
+    //strcpy(pkgName,"/sbin/ldconfig");
+    bool isInIsoft = CheckPkgInCachex(CacheIsoft,pkgName,false);
+    // pkg is in isoft, return;
+    if (isInIsoft) {
+        //printf("\ntrace:%s,%d,find pkg[%s] in isoft,installed.\n",__FUNCTION__,__LINE__,pkgName);
+        return isInIsoft;
+    }
+
+    // return the result:true--in sys; false--not installed.
+    isInIsoft = CheckPkgInCachex(Cache,pkgName,true);
+    if(isInIsoft) {
+        //printf("\ntrace:%s,%d,find pkg[%s] in sys,installed.\n",__FUNCTION__,__LINE__,pkgName);
+    } else {
+        //printf("\ntrace:%s,%d,can find pkg[%s] in sys,not installed.\n",__FUNCTION__,__LINE__,pkgName);
+    }
+
+    return isInIsoft;
+
+}
+/*
+* todo: pkgName-->list;
+* if pkgname in list, return;
+* else go on.
+*/
+const int g_pkgNamesNum = 1000;
+char g_pkgNames[g_pkgNamesNum][256];
+bool pkgInList(const char *pkgName)
+{
+    int i = 0;
+    bool find = false;
+
+    if (!pkgName || pkgName[0] ==0) {
+        return false;
+    }
+
+    for (i= 0;i<g_pkgNamesNum;i++) {
+        if(g_pkgNames[i][0]==0) {
+            break;
+        } else if (strcmp(g_pkgNames[i],pkgName) == 0) {
+            find = true;
+            break;
+        }
+    }
+
+    if (!find) {
+        if (i >= g_pkgNamesNum) {
+            printf("\ntrace:%s,%d,[%d] > max.never go here!\n",__FUNCTION__,__LINE__,i);
+            return find;
+        }
+        snprintf(g_pkgNames[i],255,"%s",pkgName);
+    }
+    return find;
+
+}
+
+bool pkgProblemResolver::markInstallAll(const char *pkgName)
+{
+    if (!pkgName || pkgName[0] ==0) {
+        return false;
+    }
+    if (pkgInList(pkgName)) {
+        //printf("\ntrace:%s,%d,pkg[%s] is marked.\n",__FUNCTION__,__LINE__,pkgName);
+        return true;
+    }
+    bool isInstalled = false;
+    bool isOwner = false;
+    char ownerName[512]="";
+    //printf("\ntrace:%s,%d,->[%s]g_max_deep[%d]\n",__FUNCTION__,__LINE__,pkgName,g_max_deep);
+
+    for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; I++) {
+        if (strcmp(I.Name(),pkgName) == 0) {
+            Cache.MarkInstall(I,false);
+        }
+
+        pkgCache::DepIterator Dep = I.RevDependsList();
+        for (; Dep.end() == false; Dep++) {
+            if (strcmp(Dep.ParentPkg().Name(),pkgName) == 0) {
+
+                isOwner = false;
+                ownerName[0]=0;
+                for (pkgCache::PrvIterator P = I.ProvidesList(); P.end() == false; P++)
+                {
+                    pkgCache::PkgIterator PPkg = P.OwnerPkg();
+                    //printf("\ntrace:%s,%d,pkg name[%s]-->p[%s]\n",__FUNCTION__,__LINE__,I.Name(),PPkg.Name());
+                    isOwner = true;
+                    memset(ownerName,0,sizeof(ownerName));
+                    snprintf(ownerName,sizeof(ownerName),"%s",PPkg.Name());
+
+                }
+
+                //printf("\ntrace:%s,%d,pkg name[%s]-->p[%s],ownername[%s]\n",__FUNCTION__,__LINE__,I.Name(),pkgName,ownerName);
+
+                isInstalled = false;
+                if (g_Cache && g_CacheIsoft) {
+                    if (isOwner)
+                        isInstalled = getPkgInstallStatex(*g_Cache,*g_CacheIsoft,ownerName);
+                    else
+                        isInstalled = getPkgInstallStatex(*g_Cache,*g_CacheIsoft,I.Name());
+                }
+
+
+               if (isInstalled) {
+                   continue;
+               }
+               // to find I by owner name
+               if (isOwner&& strcmp(ownerName,I.Name())!= 0) {
+                   for (pkgCache::PkgIterator J = Cache.PkgBegin(); J.end() == false; J++) {
+                       if (strcmp(J.Name(),ownerName) == 0) {
+                           Cache.MarkInstall(J,false);
+                           markInstallAll(ownerName);
+                       }
+                   }
+               }
+
+               //printf("\ntrace:%s,%d,[%s]-->[%s]or[%s],state[%s]deep[%d]\n",__FUNCTION__,__LINE__,
+               //       Dep.ParentPkg().Name(),I.Name(),ownerName,isInstalled?"installed":"not installed",g_max_deep);
+
+                Cache.MarkInstall(I,false);
+                markInstallAll(I.Name());
+
+            }
+        }
+    }
+
+    return false;
+
+}
+
+
+bool pkgProblemResolver::markDeleteAll(const char *pkgName,int *deep)
+{
+    if (!pkgName || pkgName[0] ==0) {
+        return false;
+    }
+
+    if (pkgInList(pkgName)) {
+        //printf("\ntrace:%s,%d,pkg[%s] is marked.\n",__FUNCTION__,__LINE__,pkgName);
+        return true;
+    }
+
+    bool isOwner = false;
+    char ownerName[256] = "";
+
+    for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; I++) {
+#if 1
+        //printf("\ntrace:%s,%d,pkg name[%s]\n",__FUNCTION__,__LINE__,I.Name());
+        isOwner = false;
+        ownerName[0]=0;
+        for (pkgCache::PrvIterator P = I.ProvidesList(); P.end() == false; P++)
+        {
+            pkgCache::PkgIterator PPkg = P.OwnerPkg();
+            //printf("\ntrace:%s,%d,pkg name[%s]-->p[%s]\n",__FUNCTION__,__LINE__,I.Name(),PPkg.Name());
+            isOwner = true;
+            memset(ownerName,0,sizeof(ownerName));
+            snprintf(ownerName,sizeof(ownerName),"%s",PPkg.Name());
+            if(strcmp(ownerName,pkgName) == 0)
+                break;
+
+        }
+        // owner name(or i name)  vs pkg name
+        if ( (ownerName[0] == 0 && strcmp(I.Name(),pkgName) == 0) ||
+             (ownerName[0]!=0 && strcmp(ownerName,pkgName) == 0) ) {
+
+            //printf("\ntrace:%s,%d,pkg name[%s]-->p[%s],ownername[%s]\n",__FUNCTION__,__LINE__,I.Name(),pkgName,ownerName);
+
+            Cache.MarkDelete(I);
+            pkgCache::DepIterator Dep = I.RevDependsList();
+            for (; Dep.end() == false; Dep++) {
+
+                bool done = false;
+
+                // use revdep owner name
+                for (pkgCache::PkgIterator J = Cache.PkgBegin(); J.end() == false; J++) {
+                    // find J
+                    if (strcmp(J.Name(),Dep.ParentPkg().Name()) == 0) {
+                        isOwner = false;
+                        ownerName[0]=0;
+                        // find revdep owner name in J
+                        for (pkgCache::PrvIterator P = J.ProvidesList(); P.end() == false; P++)
+                        {
+                            pkgCache::PkgIterator PPkg = P.OwnerPkg();
+                            //printf("\ntrace:%s,%d,pkg name[%s]-->p[%s]\n",__FUNCTION__,__LINE__,J.Name(),PPkg.Name());
+                            isOwner = true;
+                            memset(ownerName,0,sizeof(ownerName));
+                            snprintf(ownerName,sizeof(ownerName),"%s",PPkg.Name());
+                        }
+
+                        //printf("\ntrace:%s,%d,[%s]or[%s]-->[%s]\n",__FUNCTION__,__LINE__,
+                        //              Dep.ParentPkg().Name(),ownerName,J.Name());
+                        if (isOwner)
+                            markDeleteAll(ownerName,deep);
+                        else
+                            markDeleteAll(Dep.ParentPkg().Name(),deep);
+
+                        done = true;
+                    }
+                }
+
+                if (!done) {
+
+                    printf("\ntrace:%s,%d,[%s]-->[%s]\n",__FUNCTION__,__LINE__,
+                              Dep.ParentPkg().Name(),I.Name());
+                    markDeleteAll(Dep.ParentPkg().Name(),deep);
+                }
+            }
+        }
+
+#else
+        int len = strlen(pkgName);
+        // pkgName is unragular.
+        if (strncmp(I.Name(),pkgName,len) == 0) { // I.name => ownername-->get J -->J.RevDependsList();
+        //if (strcmp(I.Name(),pkgName) == 0) {
+            if (I.Name()[len] == '(') {
+                continue;
+            }
+            Cache.MarkDelete(I);
+            pkgCache::DepIterator Dep = I.RevDependsList();
+            for (; Dep.end() == false; Dep++) {
+                printf("\ntrace:%s,%d,[%s]-->[%s]\n",__FUNCTION__,__LINE__,
+                                  Dep.ParentPkg().Name(),I.Name());
+                markDeleteAll(Dep.ParentPkg().Name(),deep);
+            }
+        }
+
+/*
+trace:markDeleteAll,1473,[python3-crypto]-->[libtomcrypt-1.17.so.0()(64bit)]
+trace:markDeleteAll,1473,[python3-dns]-->[python3-crypto]
+trace:markDeleteAll,1473,[python-crypto]-->[libtomcrypt-1.17.so.0()(64bit)]
+trace:markDeleteAll,1473,[python-dns]-->[python-crypto]
+*/
+#endif
+    }
+
+    return false;
+}
+
+
+bool pkgProblemResolver::ResolveAll(const char *pkgName,char action)
+{
+
+    if (action == 's') {
+        memset(&g_pkgNames,0,g_pkgNamesNum*256);
+        g_Cache = &Cache;
+        return true;
+    }
+    if (action == 'a') {
+        g_CacheIsoft = &Cache;
+        return true;
+    }
+    if (action == 'd') {
+        // no.1
+        for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; I++) {
+            if (strcmp(I.Name(),pkgName) == 0) {
+                Cache.MarkDelete(I);
+            }
+        }
+
+        // no.2
+        int deep = 0;
+        markDeleteAll(pkgName,&deep);
+        return true;
+    } else if (action == 'i') {
+        for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; I++) {
+            if (strcmp(I.Name(),pkgName) == 0) {
+                Cache.MarkInstall(I,false);
+                markInstallAll(I.Name());
+                return true;
+            }
+        }
+
+        return true;
+    }
+
+    return true;
+}
+
 									/*}}}*/
 // ProblemResolver::ResolveByKeep - Resolve problems using keep		/*{{{*/
 // ---------------------------------------------------------------------
diff --git a/apt-pkg/algorithms.h b/apt-pkg/algorithms.h
index be554d8..d75abee 100644
--- a/apt-pkg/algorithms.h
+++ b/apt-pkg/algorithms.h
@@ -111,6 +111,10 @@ class pkgProblemResolver
    
    // Try to intelligently resolve problems by installing and removing packages   
    bool Resolve(bool BrokenFix = false);
+
+   bool ResolveAll(const char *pkgName,char action);
+   bool markDeleteAll(const char *pkgName,int *deep);
+   bool markInstallAll(const char *pkgName);
    
    // Try to resolve problems only by using keep
    bool ResolveByKeep();
diff --git a/apt-pkg/cachefile.cc b/apt-pkg/cachefile.cc
index 6b13d81..c58bb44 100644
--- a/apt-pkg/cachefile.cc
+++ b/apt-pkg/cachefile.cc
@@ -22,12 +22,16 @@
     
 #include <apti18n.h>
 									/*}}}*/
+bool g_useIsoftApp = false;
 
 // CacheFile::CacheFile - Constructor					/*{{{*/
 // ---------------------------------------------------------------------
 /* */
-pkgCacheFile::pkgCacheFile() : Map(0), Cache(0), DCache(0), Policy(0)
+//pkgCacheFile::pkgCacheFile() : Map(0), Cache(0), DCache(0), Policy(0)
+pkgCacheFile::pkgCacheFile(bool useIsoft) : Map(0), Cache(0), DCache(0), Policy(0)
 {
+   m_useIsoft = useIsoft;
+   g_useIsoftApp = useIsoft;
 }
 									/*}}}*/
 // CacheFile::~CacheFile - Destructor					/*{{{*/
@@ -48,7 +52,7 @@ pkgCacheFile::~pkgCacheFile()
 bool pkgCacheFile::BuildCaches(OpProgress &Progress,bool WithLock)
 {
    if (WithLock == true)
-      if (_system->Lock() == false)
+      if (_system->Lock(m_useIsoft) == false)
 	 return false;
 
    // CNC:2002-07-06
diff --git a/apt-pkg/cachefile.h b/apt-pkg/cachefile.h
index 036df2e..4131739 100644
--- a/apt-pkg/cachefile.h
+++ b/apt-pkg/cachefile.h
@@ -45,9 +45,11 @@ class pkgCacheFile
    bool BuildCaches(OpProgress &Progress,bool WithLock = true);
    bool Open(OpProgress &Progress,bool WithLock = true);
    void Close();
-   
-   pkgCacheFile();
+
+   pkgCacheFile(bool useIsoft = false);   
    ~pkgCacheFile();
+   private:
+   bool m_useIsoft;
 };
 
 #endif
diff --git a/apt-pkg/contrib/configuration.cc b/apt-pkg/contrib/configuration.cc
index 251ae17..0249e58 100644
--- a/apt-pkg/contrib/configuration.cc
+++ b/apt-pkg/contrib/configuration.cc
@@ -35,6 +35,7 @@ using namespace std;
 									/*}}}*/
 
 Configuration *_config = new Configuration;
+Configuration *_configApp = new Configuration;
 
 // Configuration::Configuration - Constructor				/*{{{*/
 // ---------------------------------------------------------------------
diff --git a/apt-pkg/contrib/configuration.h b/apt-pkg/contrib/configuration.h
index 10863d5..4132ee4 100644
--- a/apt-pkg/contrib/configuration.h
+++ b/apt-pkg/contrib/configuration.h
@@ -102,6 +102,7 @@ class Configuration
 };
 
 extern Configuration *_config;
+extern Configuration *_configApp;
 
 bool ReadConfigFile(Configuration &Conf,string FName,bool AsSectional = false,
 		    unsigned Depth = 0);
diff --git a/apt-pkg/contrib/mmap.cc b/apt-pkg/contrib/mmap.cc
index 6e4f1c0..ca5fa6a 100644
--- a/apt-pkg/contrib/mmap.cc
+++ b/apt-pkg/contrib/mmap.cc
@@ -25,6 +25,7 @@
 #include <apt-pkg/error.h>
 
 #include <apti18n.h>
+#include <stdio.h>
 
 #include <cstring>
 #include <sys/mman.h>
@@ -65,7 +66,9 @@ MMap::~MMap()
 bool MMap::Map(FileFd &Fd)
 {
    iSize = Fd.Size();
-   
+#ifdef APT_RPM_DEBUG
+  printf("\ntrace:%s,%d,size[%d]\n",__FUNCTION__,__LINE__,iSize); 
+#endif
    // Set the permissions.
    int Prot = PROT_READ;
    int Map = MAP_SHARED;
@@ -157,7 +160,9 @@ DynamicMMap::DynamicMMap(FileFd &F,unsigned long Flags,size_t WorkSpace) :
       char C = 0;
       Fd->Write(&C,sizeof(C));
    }
-   
+#if APT_RPM_DEBUG
+   printf("\ntrace:%s,%d,\n",__FUNCTION__,__LINE__);
+#endif
    Map(F);
    iSize = EndOfFile;
 }
diff --git a/apt-pkg/contrib/progress.cc b/apt-pkg/contrib/progress.cc
index 2628981..22db60f 100644
--- a/apt-pkg/contrib/progress.cc
+++ b/apt-pkg/contrib/progress.cc
@@ -281,6 +281,9 @@ void InstHashProgress::Update()
           (*PackageData)["release"] + "." +
 	  (*PackageData)["arch"]; 
    }
+#ifdef APT_RPM_DEBUG
+printf("\ntrace:%s,%d,s[%s]\n",__FUNCTION__,__LINE__,s.c_str());
+#endif
    const int namemax = 40;
    cout << "\r";
    cout << setw(namemax) << s.substr(0, namemax) << " ";
diff --git a/apt-pkg/depcache.cc b/apt-pkg/depcache.cc
index 95415ca..f178240 100644
--- a/apt-pkg/depcache.cc
+++ b/apt-pkg/depcache.cc
@@ -230,7 +230,8 @@ bool pkgDepCache::CheckDep(DepIterator Dep,int Type,PkgIterator &Res)
 	    break;
 
 	 case InstallVersion:
-	    if (PkgState[Pkg->ID].InstallVer != 0)
+	    // TODO: check dependes
+        if (PkgState[Pkg->ID].InstallVer != 0)
 	       if (VS.CheckDep(PkgState[Pkg->ID].InstVerIter(*this).VerStr(),
 				       Dep) == true)
 		  return true;
@@ -734,16 +735,23 @@ void pkgDepCache::MarkDelete(PkgIterator const &Pkg, bool rPurge)
 // DepCache::MarkInstall - Put the package in the install state		/*{{{*/
 // ---------------------------------------------------------------------
 /* */
-void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
+#include <stdio.h>
+bool pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
 			      unsigned long Depth)
 {
-   if (Depth > 100)
-      return;
+      //printf("\ntrace:%s,%d,pkgname[%s]\n",__FUNCTION__,__LINE__,Pkg.Name());
+   if (Depth > 100) {
+      printf("\ntrace:%s,%d,\n",__FUNCTION__,__LINE__);
+      return false;
+   }
    
    // Simplifies other routines.
-   if (Pkg.end() == true)
-      return;
-   
+   if (Pkg.end() == true) {
+      printf("\ntrace:%s,%d,\n",__FUNCTION__,__LINE__);
+      return false;
+   }
+  //trace:MarkInstall,758,b[not b],mode[1]==[2]?? can[f5b17710]==[f590c000]??
+  //trace:MarkInstall,758,b[not b],mode[1]==[2]?? can[0]==[f590c000]?? 
    /* Check that it is not already marked for install and that it can be 
       installed */
    StateCache &P = PkgState[Pkg->ID];
@@ -753,16 +761,28 @@ void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
    {
       if (P.CandidateVer == (Version *)Pkg.CurrentVer() && P.InstallVer == 0)
 	 MarkKeep(Pkg);
-      return;
+#if 0
+      //trace:MarkInstall,762,1[not P.InstBroken()],2[1]==[2]? ver[0]==[0]??
+      printf("trace:%s,%d,pkg[%s]\t1[%s],2[%x]==[%x]? ver[%x]==[%x]??\n",__FUNCTION__,__LINE__,Pkg.Name(),
+	 P.InstBroken()?"P.InstBroken()":"not P.InstBroken()",
+	 P.Mode,ModeInstall,
+	 P.CandidateVer,(Version *)Pkg.CurrentVer());
+#endif
+      //printf("\ntrace:%s,%d,pkg[%s] is not install.\n",__FUNCTION__,__LINE__,Pkg.Name());
+      return false;
    }
 
    // See if there is even any possible instalation candidate
-   if (P.CandidateVer == 0)
-      return;
+   if (P.CandidateVer == 0) {
+      printf("\ntrace:%s,%d,\n",__FUNCTION__,__LINE__);
+      return false;
+   }
    
    // We dont even try to install virtual packages..
-   if (Pkg->VersionList == 0)
-      return;
+   if (Pkg->VersionList == 0) {
+      printf("\ntrace:%s,%d,\n",__FUNCTION__,__LINE__);
+      return false;
+   }
    
    /* Target the candidate version and remove the autoflag. We reset the
       autoflag below if this was called recursively. Otherwise the user
@@ -780,8 +800,9 @@ void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
    Update(Pkg);
    AddSizes(Pkg);
    
-   if (AutoInst == false)
-      return;
+   if (AutoInst == false) {//printf("\ntrace:%s,%d,\n",__FUNCTION__,__LINE__);
+      return false;
+   }
 
    DepIterator Dep = P.InstVerIter(*this).DependsList();
    for (; Dep.end() != true;)
@@ -884,6 +905,8 @@ void pkgDepCache::MarkInstall(PkgIterator const &Pkg,bool AutoInst,
 	 continue;
       }      
    }
+      //printf("\ntrace:%s,%d,pkgname[%s] is set install.\n",__FUNCTION__,__LINE__,Pkg.Name());
+   return true;
 }
 									/*}}}*/
 // DepCache::SetReInstall - Set the reinstallation flag			/*{{{*/
diff --git a/apt-pkg/depcache.h b/apt-pkg/depcache.h
index c720928..658f37f 100644
--- a/apt-pkg/depcache.h
+++ b/apt-pkg/depcache.h
@@ -191,7 +191,8 @@ class pkgDepCache : protected pkgCache::Namespace
    // Manipulators
    void MarkKeep(PkgIterator const &Pkg,bool Soft = false);
    void MarkDelete(PkgIterator const &Pkg,bool Purge = false);
-   void MarkInstall(PkgIterator const &Pkg,bool AutoInst = true,
+   //void MarkInstall(PkgIterator const &Pkg,bool AutoInst = true,
+   bool MarkInstall(PkgIterator const &Pkg,bool AutoInst = true,
 		    unsigned long Depth = 0);
    void SetReInstall(PkgIterator const &Pkg,bool To);
    void SetCandidateVersion(VerIterator TargetVer);
diff --git a/apt-pkg/init.cc b/apt-pkg/init.cc
index 89a2d54..7993c85 100644
--- a/apt-pkg/init.cc
+++ b/apt-pkg/init.cc
@@ -37,7 +37,7 @@ const char *pkgOS = COMMON_OS;
 /* Directories are specified in such a way that the FindDir function will
    understand them. That is, if they don't start with a / then their parent
    is prepended, this allows a fair degree of flexability. */
-bool pkgInitConfig(Configuration &Cnf)
+bool pkgInitConfig(Configuration &Cnf,bool useIsoftApp)
 {
    // General APT things
    if (strcmp(COMMON_OS,"linux") == 0 ||
@@ -50,7 +50,7 @@ bool pkgInitConfig(Configuration &Cnf)
    Cnf.Set("Dir","/");
    
    // State   
-   Cnf.Set("Dir::State","var/lib/apt/");
+   Cnf.Set("Dir::State",useIsoftApp?"var/lib/isoftapp/":"var/lib/apt/");
    
    struct stat St;   
    if (stat(Cnf.FindDir("Dir::State").c_str(),&St) != 0)
@@ -61,27 +61,31 @@ bool pkgInitConfig(Configuration &Cnf)
    Cnf.Set("Dir::State::cdroms","cdroms.list");
    
    // Cache
-   Cnf.Set("Dir::Cache","var/cache/apt/");
+   Cnf.Set("Dir::Cache",useIsoftApp?"var/cache/isoftapp/":"var/cache/apt/");
    Cnf.Set("Dir::Cache::archives","archives/");
    Cnf.Set("Dir::Cache::srcpkgcache","srcpkgcache.bin");
    Cnf.Set("Dir::Cache::pkgcache","pkgcache.bin");
    
    // Configuration
-   Cnf.Set("Dir::Etc","etc/apt/");
+   Cnf.Set("Dir::Etc",useIsoftApp?"etc/isoftapp/":"etc/isoftapp");
    Cnf.Set("Dir::Etc::sourcelist","sources.list");
    // CNC:2003-03-03
    Cnf.Set("Dir::Etc::sourceparts","sources.list.d");
    Cnf.Set("Dir::Etc::vendorlist","vendors.list");
    Cnf.Set("Dir::Etc::vendorparts","vendors.list.d");
-   Cnf.Set("Dir::Etc::main","apt.conf");
-   Cnf.Set("Dir::Etc::parts","apt.conf.d");
+   Cnf.Set("Dir::Etc::main",useIsoftApp?"isoftapp.conf":"apt.conf");
+   Cnf.Set("Dir::Etc::parts",useIsoftApp?"isoftapp.conf.d":"apt.conf.d");
    Cnf.Set("Dir::Etc::preferences","preferences");
-   Cnf.Set("Dir::Bin::methods",LIBDIR "/apt/methods");
-	      
+   if (useIsoftApp) {
+       Cnf.Set("Dir::Bin::methods",LIBDIR "/isoftapp/methods");
+   } else {
+       Cnf.Set("Dir::Bin::methods",LIBDIR "/apt/methods");
+   }
+
    bool Res = true;
    
    // Read an alternate config file
-   const char *Cfg = getenv("APT_CONFIG");
+   const char *Cfg = getenv(useIsoftApp?"ISOFTAPP_CONFIG":"ISOFTAPP_CONFIG");
    if (Cfg != 0 && FileExists(Cfg) == true)
       Res &= ReadConfigFile(Cnf,Cfg);
    
@@ -94,7 +98,7 @@ bool pkgInitConfig(Configuration &Cnf)
    string FName = Cnf.FindFile("Dir::Etc::main");
    if (FileExists(FName) == true)
       Res &= ReadConfigFile(Cnf,FName);
-   
+
    if (Res == false)
       return false;
    
diff --git a/apt-pkg/init.h b/apt-pkg/init.h
index 9252caa..6976b81 100644
--- a/apt-pkg/init.h
+++ b/apt-pkg/init.h
@@ -26,7 +26,7 @@ extern const char *pkgLibVersion;
 extern const char *pkgOS;
 extern const char *pkgCPU;
 
-bool pkgInitConfig(Configuration &Cnf);
+bool pkgInitConfig(Configuration &Cnf,bool useIsoftApp);
 bool pkgInitSystem(Configuration &Cnf,pkgSystem *&Sys);
 
 #ifdef APT_COMPATIBILITY
diff --git a/apt-pkg/packagemanager.cc b/apt-pkg/packagemanager.cc
index e0e4f8a..ca40485 100644
--- a/apt-pkg/packagemanager.cc
+++ b/apt-pkg/packagemanager.cc
@@ -672,6 +672,9 @@ pkgPackageManager::OrderResult pkgPackageManager::DoInstall(InstProgress *Prog)
 									/*}}}*/
 pkgPackageManager::OrderResult pkgPackageManager::DoInstall()
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    InstProgress *Prog;
    pkgPackageManager::OrderResult res;
    if (_config->FindB("RPM::Interactive",true)) {
diff --git a/apt-pkg/pkgcache.cc b/apt-pkg/pkgcache.cc
index d65a0c7..ee2e0ea 100644
--- a/apt-pkg/pkgcache.cc
+++ b/apt-pkg/pkgcache.cc
@@ -175,6 +175,13 @@ unsigned long pkgCache::sHash(const char *Str) const
 #endif
 
 									/*}}}*/
+#if 0
+int pkgCache::PkgIterator::SetInstallState(int State)
+{
+   PkgP->PkgState = State;
+   return 0;
+}
+#endif
 // Cache::FindPkg - Locate a package by name				/*{{{*/
 // ---------------------------------------------------------------------
 /* Returns 0 on error, pointer to the package otherwise */
@@ -426,7 +433,6 @@ pkgCache::Version **pkgCache::DepIterator::AllTargets()
 	 if (Res != 0)
 	    *End++ = I.OwnerVer();
       }
-      
       // Do it again and write it into the array
       if (Res == 0)
       {
diff --git a/apt-pkg/pkgcache.h b/apt-pkg/pkgcache.h
index e897245..bff325b 100644
--- a/apt-pkg/pkgcache.h
+++ b/apt-pkg/pkgcache.h
@@ -126,7 +126,7 @@ class pkgCache
    inline bool Sync() {return Map.Sync();}
    inline MMap &GetMap() {return Map;}
    inline void *DataEnd() {return ((unsigned char *)Map.Data()) + Map.Size();}
-      
+
    // String hashing function (512 range)
    inline unsigned long Hash(const string & S) const {return sHash(S);}
    inline unsigned long Hash(const char *S) const {return sHash(S);}
@@ -213,7 +213,7 @@ struct pkgCache::Package
    map_ptrloc VersionList;       // Version
    map_ptrloc CurrentVer;        // Version
    map_ptrloc Section;           // StringTable (StringItem)
-      
+
    // Linked list 
    map_ptrloc NextPackage;       // Package
    map_ptrloc RevDepends;        // Dependency
diff -Naur a/apt-pkg/pkgcachegen.cc b/apt-pkg/pkgcachegen.cc 
--- a/apt-pkg/pkgcachegen.cc      2011-04-07 21:18:59.000000000 +0800
+++ b/apt-pkg/pkgcachegen.cc        2015-11-26 17:15:14.998452468 +0800
@@ -768,7 +779,7 @@
    unsigned long EndOfSource = Files.size();
    if (_system->AddStatusFiles(Files) == false)
       return false;
-   
+
    // Decide if we can write to the files..
    string CacheFile = _config->FindFile("Dir::Cache::pkgcache");
    string SrcCacheFile = _config->FindFile("Dir::Cache::srcpkgcache");
@@ -779,20 +790,21 @@
       Writeable = access(flNotFile(CacheFile).c_str(),W_OK) == 0;
    else
       if (SrcCacheFile.empty() == false)
-	 Writeable = access(flNotFile(SrcCacheFile).c_str(),W_OK) == 0;
-   
-   if (Writeable == false && AllowMem == false && CacheFile.empty() == false)
-      return _error->Error(_("Unable to write to %s"),flNotFile(CacheFile).c_str());
-   
+         Writeable = access(flNotFile(SrcCacheFile).c_str(),W_OK) == 0;
+
+   // sudo ./apt-pkg:Writeable:true;
+   //if (Writeable == false && AllowMem == false && CacheFile.empty() == false)
+   //   return _error->Error(_("Unable to write to %s"),flNotFile(CacheFile).c_str());
+
    Progress.OverallProgress(0,1,1,_("Reading Package Lists"));
-   
+
    // Cache is OK, Fin.
-   if (CheckValidity(CacheFile,Files.begin(),Files.end(),OutMap) == true)
+   if (0&&CheckValidity(CacheFile,Files.begin(),Files.end(),OutMap) == true)
    {
       Progress.OverallProgress(1,1,1,_("Reading Package Lists"));
       return true;
    }
-   
+
    // CNC:2002-07-03
 #if DYING
    if (_system->PreProcess(Files.begin(),Files.end(),Progress) == false) 

diff --git a/apt-pkg/pkgsystem.h b/apt-pkg/pkgsystem.h
index 2ac0893..b4b2e80 100644
--- a/apt-pkg/pkgsystem.h
+++ b/apt-pkg/pkgsystem.h
@@ -62,7 +62,8 @@ class pkgSystem
    
    /* Prevent other programs from touching shared data not covered by
       other locks (cache or state locks) */
-   virtual bool Lock() = 0;
+   //virtual bool Lock() = 0;
+   virtual bool Lock(bool useIsoft = false) = 0;
    virtual bool UnLock(bool NoErrors = false) = 0;
 
    // CNC:2002-07-06
diff --git a/apt-pkg/rpm/rpmhandler.cc b/apt-pkg/rpm/rpmhandler.cc
index 0b600d3..41475a9 100644
--- a/apt-pkg/rpm/rpmhandler.cc
+++ b/apt-pkg/rpm/rpmhandler.cc
@@ -62,6 +62,12 @@ bool HideZeroEpoch;
 
 static rpmds rpmlibProv = NULL;
 
+#define ISOFTAPP_DIR "/var/lib/isoft-app"
+#define SYSAPP_DIR "/var/lib/rpm"
+extern bool g_useIsoftApp;
+string g_dbpath_str_true ;
+string g_dbpath_str_false;
+
 string RPMHandler::EVR() const
 {
    string e = Epoch();
@@ -545,9 +551,17 @@ string RPMDirHandler::HashType() const
    return "MD5-Hash";
 }
 
-RPMDBHandler::RPMDBHandler(bool WriteLock)
+RPMDBHandler::RPMDBHandler(bool WriteLock,bool useIsoftApp)
    : Handler(0), WriteLock(WriteLock)
 {
+   g_useIsoftApp = useIsoftApp;
+
+   if (useIsoftApp) {
+       rpmtsSetMacro(ISOFTAPP_DIR);
+   } else {
+       rpmtsSetMacro(SYSAPP_DIR);
+   }
+
    RpmIter = NULL;
    string Dir = _config->Find("RPM::RootDir", "/");
    
@@ -566,7 +580,14 @@ RPMDBHandler::RPMDBHandler(bool WriteLock)
 
    Handler = rpmtsCreate();
    rpmtsSetVSFlags(Handler, (rpmVSFlags_e)-1);
-   rpmtsSetRootDir(Handler, Dir.c_str());
+   if (useIsoftApp) {
+      rpmtsSetRootDir(Handler, Dir.c_str());
+      rpmtsSetMacro(ISOFTAPP_DIR);
+   }
+   else {
+      rpmtsSetRootDir(Handler, Dir.c_str());
+      rpmtsSetMacro(SYSAPP_DIR);
+   }
 
    RpmIter = raptInitIterator(Handler, RPMDBI_PACKAGES, NULL, 0);
    if (RpmIter == NULL) {
@@ -627,14 +648,26 @@ RPMDBHandler::~RPMDBHandler()
 
 string RPMDBHandler::DataPath(bool DirectoryOnly)
 {
+    if (g_useIsoftApp) {
+        rpmtsSetMacro(ISOFTAPP_DIR);
+    } else {
+        rpmtsSetMacro(SYSAPP_DIR);
+    }
    string File = "Packages";
    char *tmp = (char *) rpmExpand("%{_dbpath}", NULL);
    string DBPath(_config->Find("RPM::RootDir")+tmp);
+   // TODO: here need to modify if not ok.
+
    free(tmp);
 
    if (DirectoryOnly == true)
-       return DBPath;
-   else
+        g_dbpath_str_true = DBPath;
+    else
+        g_dbpath_str_false = DBPath+"/"+File;
+
+    if (DirectoryOnly == true)
+           return DBPath;
+    else
        return DBPath+"/"+File;
 }
 
@@ -943,6 +976,9 @@ string RPMRepomdHandler::SourceRpm() const
 
 bool RPMRepomdHandler::PRCO(unsigned int Type, vector<Dependency*> &Deps) const
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    xmlNode *format = XmlFindNode(NodeP, "format");
    xmlNode *prco = NULL;
 
@@ -1401,6 +1437,9 @@ string RPMSqliteHandler::HashType() const
 
 bool RPMSqliteHandler::PRCO(unsigned int Type, vector<Dependency*> &Deps) const
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    SqliteQuery *prco = NULL;
    switch (Type) {
       case pkgCache::Dep::Depends:
diff -Naur a/apt-pkg/rpm/rpmhandler.h b/apt-pkg/rpm/rpmhandler.h 
--- a/apt-pkg/rpm/rpmhandler.h    2011-04-14 02:27:40.000000000 +0800
+++ b/apt-pkg/rpm/rpmhandler.h      2015-11-25 17:00:15.166866506 +0800
@@ -214,7 +214,7 @@
 
    public:
 
-   static string DataPath(bool DirectoryOnly=true);
+   string DataPath(bool DirectoryOnly=true);
    virtual bool Skip();
    virtual bool Jump(off_t Offset);
    virtual void Rewind();
@@ -226,7 +226,7 @@
    // used by rpmSystem::DistroVer()
    bool JumpByName(string PkgName, bool Provides=false);
 
-   RPMDBHandler(bool WriteLock=false);
+   RPMDBHandler(bool WriteLock=false,bool useIsoftApp=false);
    virtual ~RPMDBHandler();
 };

diff --git a/apt-pkg/rpm/rpmindexfile.cc b/apt-pkg/rpm/rpmindexfile.cc
index 1dd1244..8b6d7b6 100644
--- a/apt-pkg/rpm/rpmindexfile.cc
+++ b/apt-pkg/rpm/rpmindexfile.cc
@@ -34,6 +34,9 @@
 
 #include <sys/stat.h>
 
+extern string g_dbpath_str_true ;
+extern string g_dbpath_str_false;
+
 vector<pkgRepository *> RepList;
 
 /* 
@@ -883,7 +886,8 @@ bool rpmDatabaseIndex::Merge(pkgCacheGenerator &Gen,OpProgress &Prog) const
       return _error->Error(_("Problem opening RPM database"));
    
    Prog.SubProgress(0,"RPM Database");
-   if (Gen.SelectFile(Handler->DataPath(false),string(),*this,pkgCache::Flag::NotSource) == false)
+   //if (Gen.SelectFile(Handler->DataPath(false),string(),*this,pkgCache::Flag::NotSource) == false)
+   if (Gen.SelectFile(g_dbpath_str_false,string(),*this,pkgCache::Flag::NotSource) == false)
       return _error->Error(_("Problem with SelectFile RPM Database"));
 
    // Store the IMS information
diff --git a/apt-pkg/rpm/rpmlistparser.cc b/apt-pkg/rpm/rpmlistparser.cc
index 749c91e..ed327a3 100644
--- a/apt-pkg/rpm/rpmlistparser.cc
+++ b/apt-pkg/rpm/rpmlistparser.cc
@@ -283,6 +283,7 @@ unsigned short rpmListParser::VersionHash()
 bool rpmListParser::ParseStatus(pkgCache::PkgIterator Pkg,
 				pkgCache::VerIterator Ver)
 {   
+   // TODO: CurrentVer
    if (!Handler->IsDatabase())  // this means we're parsing an hdlist, so it's not installed
       return true;
    
@@ -448,6 +449,7 @@ off_t rpmListParser::Size()
 // Allow-Duplicated rules.
 void rpmListParser::VirtualizePackage(string Name)
 {
+   // TODO: CurrentVer
    pkgCache::PkgIterator FromPkgI = Owner->GetCache().FindPkg(Name);
 
    // Should always be false
diff --git a/apt-pkg/rpm/rpmpackagedata.cc b/apt-pkg/rpm/rpmpackagedata.cc
index 4a002c9..6ff4012 100644
--- a/apt-pkg/rpm/rpmpackagedata.cc
+++ b/apt-pkg/rpm/rpmpackagedata.cc
@@ -327,7 +327,8 @@ bool RPMPackageData::IsDupPackage(const string &Name)
 
 RPMPackageData *RPMPackageData::Singleton()
 {
-   static RPMPackageData *data = NULL;
+   //static RPMPackageData *data = NULL;
+   RPMPackageData *data = NULL;
    if (!data)
       data = new RPMPackageData();
    return data;
diff --git a/apt-pkg/rpm/rpmpm.cc b/apt-pkg/rpm/rpmpm.cc
index 1271ea4..41af51e 100644
--- a/apt-pkg/rpm/rpmpm.cc
+++ b/apt-pkg/rpm/rpmpm.cc
@@ -398,7 +398,7 @@ bool pkgRPMExtPM::ExecRPM(Item::RPMOps op, vector<const char*> &files)
    switch (op)
    {
       case Item::RPMInstall:
-	 if (Interactive)
+     if (Interactive)
 	    operation = "-ivh";
 	 else
 	    operation = "-iv";
@@ -637,6 +637,9 @@ bool pkgRPMExtPM::Process(vector<const char*> &install,
 			  vector<const char*> &upgrade,
 			  vector<const char*> &uninstall)
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    if (uninstall.empty() == false)
        ExecRPM(Item::RPMErase, uninstall);
    if (install.empty() == false)
@@ -676,13 +679,16 @@ bool pkgRPMLibPM::AddToTransaction(Item::RPMOps op, vector<const char*> &files)
 	 case Item::RPMUpgrade:
 	    upgrade = 1;
 	 case Item::RPMInstall:
+#ifdef APT_RPM_DEBUG
+        std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << " " << std::string(*I) << std::endl;
+#endif
 	    fd = Fopen(*I, "r.ufdio");
 	    if (fd == NULL)
 	       _error->Error(_("Failed opening %s"), *I);
             rc = rpmReadPackageFile(TS, fd, *I, &hdr);
 	    if (rc != RPMRC_OK && rc != RPMRC_NOTTRUSTED && rc != RPMRC_NOKEY)
 	       _error->Error(_("Failed reading file %s"), *I);
-	    rc = rpmtsAddInstallElement(TS, hdr, *I, upgrade, 0);
+        rc = rpmtsAddInstallElement(TS, hdr, *I, upgrade, 0);
 	    if (rc)
 	       _error->Error(_("Failed adding %s to transaction %s"),
 			     *I, "(install)");
@@ -714,6 +720,9 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
 			  vector<const char*> &upgrade,
 			  vector<const char*> &uninstall)
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    int rc = 0;
    bool Success = false;
    bool Interactive = _config->FindB("RPM::Interactive",true);
@@ -760,7 +769,7 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
        AddToTransaction(Item::RPMUpgrade, upgrade);
 
    if (_config->FindB("RPM::NoDeps", false) == false) {
-      rc = rpmtsCheck(TS);
+      rc = rpmtsCheckISoftApp(TS, NULL);
       probs = rpmtsProblems(TS);
       if (rc || rpmpsNumProblems(probs) > 0) {
 	 rpmpsPrint(NULL, probs);
@@ -785,7 +794,7 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
    rpmtsSetFlags(TS, (rpmtransFlags)(rpmtsFlags(TS) | tsFlags));
    rpmtsClean(TS);
    rc = rpmtsSetNotifyCallback(TS, rpmCallback, Progress);
-   rc = rpmtsRun(TS, NULL, (rpmprobFilterFlags)probFilter);
+   rc = rpmtsRunISoftApp(TS, NULL, (rpmprobFilterFlags)probFilter);
    probs = rpmtsProblems(TS);
 
    if (rc > 0) {
diff --git a/apt-pkg/rpm/rpmrecords.cc b/apt-pkg/rpm/rpmrecords.cc
index 553bf46..f82ea99 100644
--- a/apt-pkg/rpm/rpmrecords.cc
+++ b/apt-pkg/rpm/rpmrecords.cc
@@ -24,13 +24,17 @@
 
 using namespace std;
 
+extern string g_dbpath_str_true ;
+extern string g_dbpath_str_false;
+
 // RecordParser::rpmRecordParser - Constructor				/*{{{*/
 // ---------------------------------------------------------------------
 /* */
 rpmRecordParser::rpmRecordParser(string File, pkgCache &Cache)
    : Handler(0), Buffer(0), BufSize(0), BufUsed(0)
 {
-   if (File == RPMDBHandler::DataPath(false)) {
+   //if (File == RPMDBHandler::DataPath(false)) {
+   if (File == g_dbpath_str_false ) {
       IsDatabase = true;
       Handler = rpmSys.GetDBHandler();
    } else {
diff --git a/apt-pkg/rpm/rpmsystem.cc b/apt-pkg/rpm/rpmsystem.cc
index 86d0f17..ab44696 100644
--- a/apt-pkg/rpm/rpmsystem.cc
+++ b/apt-pkg/rpm/rpmsystem.cc
@@ -39,6 +39,7 @@
 #include <time.h>
 									/*}}}*/
 extern int _rpmds_nopromote;
+extern string g_dbpath_str_false;
 
 rpmSystem rpmSys;
 
@@ -64,8 +65,10 @@ rpmSystem::~rpmSystem()
 
 RPMDBHandler *rpmSystem::GetDBHandler()
 {
-   if (RpmDB == NULL)
-      RpmDB = new RPMDBHandler();
+   if (RpmDB == NULL) {
+      RpmDB = new RPMDBHandler(false,m_IsoftApp);
+      //RpmDB = new RPMDBHandler();
+   }
    return RpmDB;
 }
 
@@ -82,15 +85,22 @@ bool rpmSystem::LockRead()
 // System::Lock - Get the lock						/*{{{*/
 // ---------------------------------------------------------------------
 /* this will open the rpm database through rpmlib, which will lock the db */
-bool rpmSystem::Lock()
+//bool rpmSystem::Lock()
+bool rpmSystem::Lock(bool useIsoft)
 {
-   if (RpmDB != NULL && RpmDB->HasWriteLock() == false)
+   m_IsoftApp = useIsoft;
+
+
+   //if (RpmDB != NULL && RpmDB->HasWriteLock() == false)
+   if (useIsoft || (RpmDB != NULL && RpmDB->HasWriteLock() == false))
    {
       delete RpmDB;
       RpmDB = NULL;
    }
-   if (RpmDB == NULL)
-      RpmDB = new RPMDBHandler(true);
+   if (RpmDB == NULL) {
+      RpmDB = new RPMDBHandler(true,m_IsoftApp);
+      //RpmDB = new RPMDBHandler(true);
+   }
    if (_error->PendingError() == true)
       return false;
    LockCount++;
@@ -106,7 +116,7 @@ bool rpmSystem::UnLock(bool NoErrors)
       return false;
    if (LockCount < 1)
       return _error->Error("Not locked");
-   if (--LockCount == 0)
+   if (--LockCount >= 0)
    {
       delete RpmDB;
       RpmDB = NULL;
@@ -185,7 +195,8 @@ signed rpmSystem::Score(Configuration const &Cnf)
 {
    signed Score = 0;
 
-   if (FileExists(RPMDBHandler::DataPath(false)))
+   //if (FileExists(RPMDBHandler::DataPath(false)))
+   if (FileExists(g_dbpath_str_false))
       Score += 10;
    if (FileExists(Cnf.FindFile("Dir::Bin::rpm","/bin/rpm")) == true)
       Score += 10;
diff --git a/apt-pkg/rpm/rpmsystem.h b/apt-pkg/rpm/rpmsystem.h
index 53629be..66f62fb 100644
--- a/apt-pkg/rpm/rpmsystem.h
+++ b/apt-pkg/rpm/rpmsystem.h
@@ -26,6 +26,7 @@ class rpmSystem : public pkgSystem
    int LockCount;
    RPMDBHandler *RpmDB;
    rpmDatabaseIndex *StatusFile;
+   bool m_IsoftApp;
    
    bool processIndexFile(rpmIndexFile *Handler,OpProgress &Progress);
    
@@ -34,7 +35,8 @@ class rpmSystem : public pkgSystem
    RPMDBHandler *GetDBHandler();
    
    virtual bool LockRead();
-   virtual bool Lock();
+   //virtual bool Lock();
+   virtual bool Lock(bool useIsoft = false);
    virtual bool UnLock(bool NoErrors = false);
    virtual pkgPackageManager *CreatePM(pkgDepCache *Cache) const;
    virtual bool Initialize(Configuration &Cnf);
diff --git a/apt-pkg/sourcelist.cc b/apt-pkg/sourcelist.cc
index 71b1ee6..0549dc1 100644
--- a/apt-pkg/sourcelist.cc
+++ b/apt-pkg/sourcelist.cc
@@ -276,6 +276,9 @@ bool pkgSourceList::ReadMainList()
       Res &= ReadAppend(Main);   
 
    string Parts = _config->FindDir("Dir::Etc::sourceparts");
+#ifdef APT_RPM_DEBUG
+   printf("\ntrace:%s,%d,Parts file[%s]\n",__FUNCTION__,__LINE__,Parts.c_str());
+#endif
    if (FileExists(Parts) == true)
       Res &= ReadSourceDir(Parts);
    
diff --git a/cmdline/apt-cache.cc b/cmdline/apt-cache.cc
index 3cd22fc..319f907 100644
--- a/cmdline/apt-cache.cc
+++ b/cmdline/apt-cache.cc
@@ -1255,6 +1255,7 @@ int main(int argc,const char *argv[])
 
    // Parse the command line and initialize the package library
    CommandLine CmdL(Args,_config);
+   /*
    if (pkgInitConfig(*_config) == false ||
        CmdL.Parse(argc,argv) == false ||
        pkgInitSystem(*_config,_system) == false)
@@ -1262,6 +1263,7 @@ int main(int argc,const char *argv[])
       _error->DumpErrors();
       return 100;
    }
+   */
 
    // See if the help should be shown
    if (_config->FindB("help") == true ||
diff --git a/cmdline/apt-cdrom.cc b/cmdline/apt-cdrom.cc
index 3388aa2..29fe53f 100644
--- a/cmdline/apt-cdrom.cc
+++ b/cmdline/apt-cdrom.cc
@@ -878,6 +878,7 @@ int main(int argc,const char *argv[])
 
    // Parse the command line and initialize the package library
    CommandLine CmdL(Args,_config);
+   /*
    if (pkgInitConfig(*_config) == false ||
        CmdL.Parse(argc,argv) == false ||
        pkgInitSystem(*_config,_system) == false)
@@ -885,6 +886,7 @@ int main(int argc,const char *argv[])
       _error->DumpErrors();
       return 100;
    }
+   */
 
    // See if the help should be shown
    if (_config->FindB("help") == true || _config->FindB("version") == true ||
diff --git a/cmdline/apt-config.cc b/cmdline/apt-config.cc
index 04febfa..ff9aba6 100644
--- a/cmdline/apt-config.cc
+++ b/cmdline/apt-config.cc
@@ -109,6 +109,7 @@ int main(int argc,const char *argv[])
 
    // Parse the command line and initialize the package library
    CommandLine CmdL(Args,_config);
+   /*
    if (pkgInitConfig(*_config) == false ||
        CmdL.Parse(argc,argv) == false ||
        pkgInitSystem(*_config,_system) == false)
@@ -116,6 +117,7 @@ int main(int argc,const char *argv[])
       _error->DumpErrors();
       return 100;
    }
+   */
 
    // See if the help should be shown
    if (_config->FindB("help") == true ||
diff --git a/cmdline/apt-get.cc b/cmdline/apt-get.cc
index b755f49..1e72654 100644
--- a/cmdline/apt-get.cc
+++ b/cmdline/apt-get.cc
@@ -65,7 +65,9 @@
 
 // CNC:2003-03-18
 #include <apt-pkg/luaiface.h>
-    
+
+#include <rpm/rpmdb.h>
+#include <fcntl.h>
 									/*}}}*/
 
 using namespace std;
@@ -76,14 +78,15 @@ ostream c2out(0);
 ofstream devnull("/dev/null");
 unsigned int ScreenWidth = 80;
 
-
 // class CacheFile - Cover class for some dependency cache functions	/*{{{*/
 // ---------------------------------------------------------------------
 /* */
 class CacheFile : public cmdCacheFile
 {
    public:
+   bool m_useIsoft = false;
    bool CheckDeps(bool AllowBroken = false);
+   bool CheckDepsCheck(pkgDepCache &Cache,pkgDepCache &CacheSys);
    bool BuildCaches(bool WithLock = true)
    {
       OpTextProgress Prog(*_config);
@@ -104,14 +107,17 @@ class CacheFile : public cmdCacheFile
    {
       // CNC:2004-03-07 - dont take lock if in download mode
       if (_config->FindB("APT::Get::Print-URIs") == true ||
-	  _config->FindB("APT::Get::Download-only") == true)
+          _config->FindB("APT::Get::Download-only") == true)
 	 return Open(false);
       else
-	 return Open(true);
+         return Open(true);
    }
-   CacheFile() : cmdCacheFile() {}
+   //CacheFile() : cmdCacheFile() {}
+   CacheFile(bool useIsoft = false) : cmdCacheFile(useIsoft) {m_useIsoft = useIsoft;}
 };
 									/*}}}*/
+CacheFile *g_cache2 = NULL; // app cache
+pkgProblemResolver *g_Fix2 =NULL;
 
 // CNC:2003-03-19
 #ifdef APT_WITH_LUA
@@ -169,7 +175,61 @@ bool CheckOnly(CacheFile &Cache)
    return true;
 }
 									/*}}}*/
+/*
+* just like bool CacheFile::CheckDeps(bool AllowBroken)
+* added: to check pkg in sys db(cache)
+*/
+bool CacheFile::CheckDepsCheck(pkgDepCache &Cache,pkgDepCache &CacheSys)
+{
+    printf("\ntrace:%s,%d.\n",__FUNCTION__,__LINE__);
+    if (_error->PendingError() == true)
+       return false;
+
+    // CNC:2003-03-19 - Might be changed by some extension.
+    #if 0
+       // Check that the system is OK
+       if (DCache->DelCount() != 0 || DCache->InstCount() != 0)
+          return _error->Error("Internal Error, non-zero counts");
+    #endif
+
+       // Apply corrections for half-installed packages
+       if (pkgApplyStatus(*DCache) == false)
+          return false;
+
+       // Nothing is broken
+       if (DCache->BrokenCount() == 0) //|| AllowBroken == true)
+          return true;
+
+       // Attempt to fix broken things
+       // TODO: fix-broken
+       if (0&&_config->FindB("APT::Get::Fix-Broken",false) == true)
+       {
+          c1out << _("Correcting dependencies...") << flush;
+          if (pkgFixBroken(*DCache) == false || DCache->BrokenCount() != 0)
+          {
+             c1out << _(" failed.") << endl;
+             ShowBroken(c1out,*this,true);
+
+             return _error->Error(_("Unable to correct dependencies"));
+          }
+          if (pkgMinimizeUpgrade(*DCache) == false)
+             return _error->Error(_("Unable to minimize the upgrade set"));
+
+          c1out << _(" Done") << endl;
+       }
+       else
+       {
+          //c1out << _("You might want to run `apt-get --fix-broken install' to correct these.") << endl;
+          //ShowBroken(c1out,*this,true);
+
+          ShowBrokenCheck(c1out,*this,true,CacheSys);
+
+          return _error->Error(_("Unmet dependencies. Try using --fix-broken."));
+       }
+
+    return true;
 
+}
 
 // CacheFile::CheckDeps - Open the cache file				/*{{{*/
 // ---------------------------------------------------------------------
@@ -186,7 +246,7 @@ bool CacheFile::CheckDeps(bool AllowBroken)
    if (DCache->DelCount() != 0 || DCache->InstCount() != 0)
       return _error->Error("Internal Error, non-zero counts");
 #endif
-   
+
    // Apply corrections for half-installed packages
    if (pkgApplyStatus(*DCache) == false)
       return false;
@@ -250,7 +310,39 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
    if (_config->FindB("APT::Get::Show-Upgraded",true) == true)
       ShowUpgraded(c1out,Cache);
    ShowDel(c1out,Cache);
+#if 0
    ShowNew(c1out,Cache);
+#else
+   // to check pkgs in g_cache2 if installed or not
+   int done = 0;
+   string List2;
+   string VersionsList2;
+   for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+   {
+      pkgCache::PkgIterator I(Cache,Cache.List[J]);
+      if (Cache[I].NewInstall() == true ) {
+
+          /* to find is installed or not in cache2.*/
+          pkgCache::PkgIterator Pkg2 = (*g_cache2)->FindPkg(I.Name());
+          pkgDepCache::StateCache &State2 = (*g_cache2)[Pkg2];
+          (*g_cache2)->MarkInstall(Pkg2,false);
+
+          if (State2.NewInstall() ) {
+              List2 += string(I.Name()) + " ";
+              VersionsList2 += string(Cache[I].CandVersion) + "\n";
+              done ++;
+          }
+
+
+
+      }
+   }
+
+   if (done >0) {
+
+       ShowList(c1out,_("The following NEW packages will be installed:"),List2,VersionsList2);
+   }
+#endif
    if (ShwKept == true)
       ShowKept(c1out,Cache);
    Fail |= !ShowHold(c1out,Cache);
@@ -259,14 +351,13 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
         Essential = !ShowEssential(c1out,Cache);
    Fail |= Essential;
    Stats(c1out,Cache);
-   
+
    // Sanity check
    if (Cache->BrokenCount() != 0)
    {
-      ShowBroken(c1out,Cache,false);
-      return _error->Error("Internal Error, InstallPackages was called with broken packages!");
+      //ShowBroken(c1out,Cache,false);
+      //return _error->Error("Internal Error, InstallPackages was called with broken packages!");
    }
-
    if (Cache->DelCount() == 0 && Cache->InstCount() == 0 &&
        Cache->BadCount() == 0)
       return true;
@@ -274,7 +365,7 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
    // No remove flag
    if (Cache->DelCount() != 0 && _config->FindB("APT::Get::Remove",true) == false)
       return _error->Error(_("Packages need to be removed but Remove is disabled."));
-       
+
    // Run the simulator ..
    if (_config->FindB("APT::Get::Simulate") == true)
    {
@@ -361,6 +452,7 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
 	 return _error->Error(_("You don't have enough free space in %s."),
 			      OutputDir.c_str());
    }
+
    
    // Fail safe check
    if (_config->FindI("quiet",0) >= 2 ||
@@ -389,7 +481,8 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
    }
    else
    {      
-      // Prompt to continue
+       // Prompt to continue
+       // TODO: TEST: set Fail=true
       if (Ask == true || Fail == true)
       {            
 	 if (_config->FindB("APT::Get::Trivial-Only",false) == true)
@@ -408,7 +501,7 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
 	 }	 
       }      
    }
-   
+
    // Just print out the uris an exit if the --print-uris flag was used
    if (_config->FindB("APT::Get::Print-URIs") == true)
    {
@@ -551,6 +644,7 @@ bool InstallPackages(CacheFile &Cache,bool ShwKept,bool Ask = true,
       if (PM->GetArchives(&Fetcher,&List,&Recs) == false)
 	 return false;
    }   
+
 }
 									/*}}}*/
 // CNC:2003-12-02
@@ -595,7 +689,7 @@ bool DownloadPackages(vector<string> &URLLst)
 // ---------------------------------------------------------------------
 /* This used to be inlined in DoInstall, but with the advent of regex package
    name matching it was split out.. */
-bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
+bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,pkgDepCache &Cache2,bool use2Cache,
 		  pkgProblemResolver &Fix,bool Remove,bool BrokenFix,
 		  unsigned int &ExpectedInst,bool AllowFail = true)
 {
@@ -606,6 +700,7 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
       for (pkgCache::PrvIterator Prv = Pkg.ProvidesList();
 	   Prv.end() == false; Prv++)
       {
+          //printf("\nhere:[%x][%x][%x]\n",Prv,&Prv,*Prv);
 	 pkgCache::PkgIterator PrvPkg = Prv.OwnerPkg();
 	 // Check if it's a different version of a package already
 	 // considered as a good solution.
@@ -724,8 +819,12 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
    
    // Check if there is something at all to install
    pkgDepCache::StateCache &State = Cache[Pkg];
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << " " << Pkg->CurrentVer << std::endl;
+#endif
    if (Remove == true && Pkg->CurrentVer == 0)
    {
+
       Fix.Clear(Pkg);
       Fix.Protect(Pkg);
       Fix.Remove(Pkg);
@@ -805,10 +904,10 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
    if (Remove == true)
    {
       Fix.Remove(Pkg);
-      Cache.MarkDelete(Pkg,_config->FindB("APT::Get::Purge",false));
+      //Cache.MarkDelete(Pkg,_config->FindB("APT::Get::Purge",false));
       return true;
    }
-   
+
    // Install it
    Cache.MarkInstall(Pkg,false);
    if (State.Install() == false)
@@ -830,6 +929,7 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
    }   
    else
       ExpectedInst++;
+
    
    // Install it with autoinstalling enabled.
    if (State.InstBroken() == true && BrokenFix == false)
@@ -1073,29 +1173,87 @@ bool DoUpgrade(CommandLine &CmdL)
    
    return InstallPackages(Cache,true);
 }
-									/*}}}*/
+
 // DoInstall - Install packages from the command line			/*{{{*/
 // ---------------------------------------------------------------------
 /* Install named packages */
 bool DoInstall(CommandLine &CmdL)
 {
+#if 0
+   int i = 0;
+   for (i = 0; CmdL.FileList[i]; i++) {
+      if (i > 1) {
+         std::cout << "SORRY: isoftapp ONLY support single one package " 
+            << CmdL.FileList[0] << " at present! so " << CmdL.FileList[0] 
+            << " " << CmdL.FileList[1] << " at first." << std::endl;
+      }
+   }
+   if (strcasecmp(CmdL.FileList[0], "remove") == 0 || 
+       strcasecmp(CmdL.FileList[0], "install") == 0) {
+      rpmdb osdb = NULL;
+      int rc = 0;
+      openDatabase("/", "/var/lib/rpm", &osdb, O_RDONLY, 0644, 0);
+      if (osdb) {
+         for (i = 1; CmdL.FileList[i]; i++)
+            rc += rpmdbCountPackages(osdb, CmdL.FileList[1]);
+         rpmdbClose(osdb);
+         osdb = NULL;
+      }
+      if (rc != 0) {
+         std::cerr << "ERROR: You can NOT remove nor install System Component!" << std::endl;
+         return false;
+      }
+   }
+#endif
+#if 1
+    // beginitx
+    CacheFile Cache;
+   if (Cache.OpenForInstall() == false ||
+       Cache.CheckDeps(CmdL.FileSize() != 1) == false)
+      return false;
+
+   CacheFile Cache2(true);
+
+   if (Cache2.OpenForInstall() == false ||
+       Cache2.CheckDeps(CmdL.FileSize() != 1) == false)
+      return false;
+
+    g_cache2 = &Cache2;
+
+#else
    CacheFile Cache;
+
    if (Cache.OpenForInstall() == false || 
        Cache.CheckDeps(CmdL.FileSize() != 1) == false)
       return false;
-   
+#endif
+
+   char pkgName[512]="";
+
    // Enter the special broken fixing mode if the user specified arguments
    bool BrokenFix = false;
    if (Cache->BrokenCount() != 0)
       BrokenFix = true;
+
+   if (Cache2->BrokenCount() != 0)
+      BrokenFix = true;
    
    unsigned int ExpectedInst = 0;
    unsigned int Packages = 0;
    pkgProblemResolver Fix(Cache);
+   pkgProblemResolver Fix2(Cache2);
+   g_Fix2 = &Fix2;
    
    bool DefRemove = false;
-   if (strcasecmp(CmdL.FileList[0],"remove") == 0)
+   bool removeAll = false;
+   bool install = false;
+   if (strcasecmp(CmdL.FileList[0],"remove") == 0) {
+      removeAll = true;
       DefRemove = true;
+   }
+   if (strcasecmp(CmdL.FileList[0],"install") == 0) {
+      install = true;
+   }
    // CNC:2004-03-22
    else if (strcasecmp(CmdL.FileList[0],"reinstall") == 0)
       _config->Set("APT::Get::ReInstall", true);
@@ -1112,6 +1270,10 @@ bool DoInstall(CommandLine &CmdL)
       // CNC:2003-03-15
       char OrigS[300];
       strcpy(OrigS,S);
+
+      snprintf(pkgName,sizeof(pkgName), "%s",S);
+
+      printf("\ntrace:%s,%d,find pkg[%s].\n",__FUNCTION__,__LINE__,pkgName);
       
       // See if we are removing and special indicators..
       bool Remove = DefRemove;
@@ -1119,7 +1281,7 @@ bool DoInstall(CommandLine &CmdL)
       bool VerIsRel = false;
       // CNC:2003-11-05
       int VerOp = 0;
-      while (Cache->FindPkg(S).end() == true)
+      while (Cache2->FindPkg(S).end() == true)
       {
 	 // Handle an optional end tag indicating what to do
 	 if (Length >= 1 && S[Length - 1] == '-')
@@ -1183,14 +1345,14 @@ bool DoInstall(CommandLine &CmdL)
 	 // CNC:2003-11-21 - Try to handle unknown file items.
 	 if (S[0] == '/')
 	 {
-	    pkgRecords Recs(Cache);
+            pkgRecords Recs(Cache2);
 	    if (_error->PendingError() == true)
 	       return false;
-	    pkgCache::PkgIterator Pkg = (*Cache).PkgBegin();
+            pkgCache::PkgIterator Pkg = (*Cache2).PkgBegin();
 	    for (; Pkg.end() == false; Pkg++)
 	    {
 	       // Should we try on all versions?
-	       pkgCache::VerIterator Ver = (*Cache)[Pkg].CandidateVerIter(*Cache);
+               pkgCache::VerIterator Ver = (*Cache2)[Pkg].CandidateVerIter(*Cache2);
 	       if (Ver.end() == false)
 	       {
 		  pkgRecords::Parser &Parse = Recs.Lookup(Ver.FileList());
@@ -1218,7 +1380,7 @@ bool DoInstall(CommandLine &CmdL)
       }
       
       // Locate the package
-      pkgCache::PkgIterator Pkg = Cache->FindPkg(S);
+      pkgCache::PkgIterator Pkg = Cache2->FindPkg(S);
       Packages++;
       if (Pkg.end() == true)
       {
@@ -1228,7 +1390,7 @@ bool DoInstall(CommandLine &CmdL)
 	    if (*I == '?' || *I == '*' || *I == '|' ||
 	        *I == '[' || *I == '^' || *I == '$')
 	       break;
-
+        printf("\ntrace:%s,%d,*I[%x].\n",__FUNCTION__,__LINE__,*I);
 	 // CNC:2003-05-15
 	 if (*I == 0) {
 #ifdef APT_WITH_LUA
@@ -1262,14 +1424,16 @@ bool DoInstall(CommandLine &CmdL)
 	       ioprintf(c1out,_("Selecting %s for '%s'\n"),
 			Pkg.Name(),OrigS);
 	    
-	       Hit |= TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,
+               Hit |= TryToInstall(Pkg,Cache,Cache,false,Fix,Remove,BrokenFix,
 				   ExpectedInst,true);
 	    }
 	 
 	    if (Hit == true)
 	       continue;
 #endif
-	    return _error->Error(_("Couldn't find package %s"),S);
+            //return _error->Error(_("Couldn't find package %s"),S);
+            ioprintf(c1out,_("Couldn't find package %s\n"),S);
+            continue;
 	 }
 
 	 // Regexs must always be confirmed
@@ -1288,9 +1452,9 @@ bool DoInstall(CommandLine &CmdL)
 	 
 	 // Run over the matches
 	 bool Hit = false;
-	 for (Pkg = Cache->PkgBegin(); Pkg.end() == false; Pkg++)
+         for (Pkg = Cache2->PkgBegin(); Pkg.end() == false; Pkg++)
 	 {
-	    if (regexec(&Pattern,Pkg.Name(),0,0,0) != 0)
+            if (regexec(&Pattern,Pkg.Name(),0,0,0) != 0)
 	       continue;
 	    
 	    // CNC:2003-11-23
@@ -1299,28 +1463,48 @@ bool DoInstall(CommandLine &CmdL)
 	    
 	    if (VerTag != 0)
 	       // CNC:2003-11-05
-	       if (TryToChangeVer(Pkg,Cache,VerOp,VerTag,VerIsRel) == false)
+               if (TryToChangeVer(Pkg,Cache,VerOp,VerTag,VerIsRel) == false)
 		  return false;
-	    
-	    Hit |= TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,
+
+            Hit |= TryToInstall(Pkg,Cache,Cache2,false,Fix,Remove,BrokenFix,
 				ExpectedInst,false);
 	 }
 	 regfree(&Pattern);
 	 
 	 if (Hit == false)
-	    return _error->Error(_("Couldn't find package %s"),S);
+            return _error->Error(_("Couldn't find package %s."),S);
       }
       else
       {
-	 if (VerTag != 0)
-	    // CNC:2003-11-05
-	    if (TryToChangeVer(Pkg,Cache,VerOp,VerTag,VerIsRel) == false)
-	       return false;
-	 if (TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,ExpectedInst) == false)
-	    return false;
+
+         if (VerTag != 0)
+            // CNC:2003-11-05
+            if (TryToChangeVer(Pkg,Cache,VerOp,VerTag,VerIsRel) == false)
+               return false;
+         pkgCache::PkgIterator Pkg2 = Cache2->FindPkg(Pkg.Name());
+         if (TryToInstall(Pkg2,Cache2,Cache2,true,Fix2,Remove,BrokenFix,ExpectedInst) == false)
+            return false;
+
       }      
+
+#if 1 // move here:
+      Fix.ResolveAll(pkgName,'s');
+      Fix2.ResolveAll(pkgName,'a');
+      Fix2.InstallProtect();
+      if (removeAll) {
+       if (Fix2.ResolveAll(pkgName,'d') == false)
+         _error->Discard();
+      }
+      if (install) {
+          if (Fix2.ResolveAll(pkgName,'i') == false)
+            _error->Discard();
+      }
+#endif
+
    }
 
+   //return false; //test 20151126
+
 // CNC:2003-03-19
 #ifdef APT_WITH_LUA
    _lua->SetDepCache(Cache);
@@ -1333,6 +1517,14 @@ bool DoInstall(CommandLine &CmdL)
    if (_config->FindB("APT::Remove-Depends",false) == true)
       Fix.RemoveDepends();
 
+   // new cache
+   if (DefRemove) {
+       if (_configApp->FindB("APT::Remove-Depends",false) == true) {
+          Fix2.RemoveDepends();
+       } else {
+       }
+   }
+
    /* If we are in the Broken fixing mode we do not attempt to fix the
       problems. This is if the user invoked install without -f and gave
       packages */
@@ -1343,12 +1535,32 @@ bool DoInstall(CommandLine &CmdL)
 
       return _error->Error(_("Unmet dependencies. Try 'apt-get --fix-broken install' with no packages (or specify a solution)."));
    }
-   
    // Call the scored problem resolver
+#if 0
    Fix.InstallProtect();
    if (Fix.Resolve(true) == false)
       _error->Discard();
+#endif
+#if 0
+    ShowBroken2(Cache,Cache2,pkgName,Cache);
+    return true;
+#endif
+#if 0 // move the following up...
 
+
+    Fix.ResolveAll(pkgName,'s');
+    Fix2.ResolveAll(pkgName,'a');
+    Fix2.InstallProtect();
+    if (removeAll) {
+     if (Fix2.ResolveAll(pkgName,'d') == false)
+       _error->Discard();
+    }
+    if (install) {
+        if (Fix2.ResolveAll(pkgName,'i') == false)
+          _error->Discard();
+    }
+
+#endif
 // CNC:2003-03-19
 #ifdef APT_WITH_LUA
    if (Cache->BrokenCount() == 0) {
@@ -1378,12 +1590,50 @@ bool DoInstall(CommandLine &CmdL)
       c1out << _("The following information may help to resolve the situation:") << endl;
       c1out << endl;
       ShowBroken(c1out,Cache,false);
+
       return _error->Error(_("Broken packages"));
+
    }   
-   
+
+    if (Cache->InstCount() != ExpectedInst) {
+        string List;
+        string VersionsList;
+        int done = 0;
+        for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+        {
+            pkgCache::PkgIterator I(Cache,Cache.List[J]);
+            if ((*Cache)[I].Install() == false)
+               continue;
+
+            // CNC:2004-06-15
+            const char **K2;
+            for (K2 = CmdL.FileList + 1; *K2 != 0; K2++)
+               if (strcmp(*K2,I.Name()) == 0)
+                   break;
+
+            if (*K2 == 0) {
+                /* to find is installed or not in cache2.*/
+                pkgCache::PkgIterator Pkg2 = Cache2->FindPkg(I.Name());
+                pkgDepCache::StateCache &State2 = Cache2[Pkg2];
+
+                Cache2->MarkInstall(Pkg2,false);
+
+                ioprintf(c1out,_("%s is already the newest version!\n"),
+                         Pkg2.Name());
+
+                done ++;
+
+            }
+        }
+        if (done > 0) {
+            ExpectedInst = Cache2->InstCount();
+        }
+
+   }
+
    /* Print out a list of packages that are going to be installed extra
       to what the user asked */
-   if (Cache->InstCount() != ExpectedInst)
+   if (Cache2->InstCount() != ExpectedInst)
    {
       string List;
       string VersionsList;
@@ -1495,10 +1745,11 @@ bool DoInstall(CommandLine &CmdL)
       return true;
 
    // See if we need to prompt
-   if (Cache->InstCount() == ExpectedInst && Cache->DelCount() == 0)
-      return InstallPackages(Cache,false,false);
-   
-   return InstallPackages(Cache,false);   
+   if (Cache2->InstCount() == ExpectedInst && Cache2->DelCount() == 0 && Cache2->InstCount() !=0) {
+      return InstallPackages(Cache2,false,false);
+   }
+
+   return InstallPackages(Cache2,false);
 }
 									/*}}}*/
 // DoDistUpgrade - Automatic smart upgrader				/*{{{*/
@@ -1569,11 +1820,28 @@ bool DoAutoClean(CommandLine &CmdL)
    for debugging */
 bool DoCheck(CommandLine &CmdL)
 {
-   CacheFile Cache;
+   CacheFile Cache(false);
    Cache.Open();
+
+#if 0
    Cache.CheckDeps();
-   
+   if (PkgInSys("libtomcrypt",Cache) ) {
+         printf("\ntrace:%s,%d,pkg[libtomcrypt] has been installed in sys.\n",__FUNCTION__,__LINE__);
+   }
+
+   system("rpm --isoftapp -Va");
+   //CacheFile Cache;
+   //Cache.Open();
+   //Cache.CheckDeps();
    return true;
+#endif
+
+   CacheFile Cache2(true);
+   Cache2.Open();
+   ShowBrokenNew(c1out,Cache2,Cache);
+
+   return true;
+
 }
 									/*}}}*/
 // DoSource - Fetch a source archive					/*{{{*/
@@ -1903,7 +2171,7 @@ bool DoBuildDep(CommandLine &CmdL)
              */
             if (IV.end() == false && 
                 Cache->VS().CheckDep(IV.VerStr(),(*D).Op,(*D).Version.c_str()) == true)
-               TryToInstall(Pkg,Cache,Fix,true,false,ExpectedInst);
+                TryToInstall(Pkg,Cache,Cache,false,Fix,true,false,ExpectedInst);
          }
 	 else // BuildDep || BuildDepIndep
          {
@@ -2038,7 +2306,7 @@ bool DoBuildDep(CommandLine &CmdL)
             if (_config->FindB("Debug::BuildDeps",false) == true)
                cout << "  Trying to install " << (*D).Package << endl;
 
-            if (TryToInstall(Pkg,Cache,Fix,false,false,ExpectedInst) == true)
+            if (TryToInstall(Pkg,Cache,Cache,false,Fix,false,false,ExpectedInst) == true)
             {
                // We successfully installed something; skip remaining alternatives
                skipAlternatives = hasAlternatives;
@@ -2318,7 +2586,8 @@ int main(int argc,const char *argv[])
 
    // Parse the command line and initialize the package library
    CommandLine CmdL(Args,_config);
-   if (pkgInitConfig(*_config) == false ||
+   CommandLine CmdLApp(Args,_configApp);
+   if (pkgInitConfig(*_config,false) == false ||
        CmdL.Parse(argc,argv) == false ||
        pkgInitSystem(*_config,_system) == false)
    {
@@ -2329,6 +2598,18 @@ int main(int argc,const char *argv[])
       return 100;
    }
 
+   if (pkgInitConfig(*_configApp,true) == false ||
+       CmdLApp.Parse(argc,argv) == false ||
+       pkgInitSystem(*_configApp,_system) == false)
+   {
+      if (_configApp->FindB("version") == true)
+         ShowHelp(CmdLApp);
+
+      _error->DumpErrors();
+      return 100;
+   }
+
+
    // See if the help should be shown
    if (_config->FindB("help") == true ||
        _config->FindB("version") == true ||
@@ -2337,6 +2618,14 @@ int main(int argc,const char *argv[])
       ShowHelp(CmdL);
       return 0;
    }
+   // See if the help should be shown
+   if (_configApp->FindB("help") == true ||
+       _configApp->FindB("version") == true ||
+       CmdLApp.FileSize() == 0)
+   {
+      ShowHelp(CmdLApp);
+      return 0;
+   }
    
    // CNC:2003-11-21
    if (CmdL.FileSize() > 1)
@@ -2362,10 +2651,38 @@ int main(int argc,const char *argv[])
 	 _config->Set("APT::Arguments::", *I);
    }
 
+   // CNC:2003-11-21
+   if (CmdLApp.FileSize() > 1)
+   {
+      // CNC:2003-11-23
+      vector<string> URLLst;
+      for (const char **I = CmdLApp.FileList + 1; *I != 0; I++)
+      {
+         if (strstr(*I, "://") != NULL)
+         {
+            URLLst.push_back(*I);
+            *I = strrchr(*I, '/')+1;
+         }
+      }
+
+      if (URLLst.empty() == false && DownloadPackages(URLLst) == false)
+      {
+            _error->DumpErrors();
+            return 100;
+      }
+
+      for (const char **I = CmdLApp.FileList + 1; *I != 0; I++)
+         _configApp->Set("APT::Arguments::", *I);
+   }
+
    // Deal with stdout not being a tty
    if (ttyname(STDOUT_FILENO) == 0 && _config->FindI("quiet",0) < 1)
       _config->Set("quiet","1");
 
+   // Deal with stdout not being a tty
+   if (ttyname(STDOUT_FILENO) == 0 && _configApp->FindI("quiet",0) < 1)
+      _configApp->Set("quiet","1");
+
    // Setup the output streams
    c0out.rdbuf(cout.rdbuf());
    c1out.rdbuf(cout.rdbuf());
@@ -2375,6 +2692,11 @@ int main(int argc,const char *argv[])
    if (_config->FindI("quiet",0) > 1)
       c1out.rdbuf(devnull.rdbuf());
 
+   if (_configApp->FindI("quiet",0) > 0)
+      c0out.rdbuf(devnull.rdbuf());
+   if (_configApp->FindI("quiet",0) > 1)
+      c1out.rdbuf(devnull.rdbuf());
+
    // Setup the signals
    signal(SIGPIPE,SIG_IGN);
    signal(SIGWINCH,SigWinch);
@@ -2411,6 +2733,9 @@ int main(int argc,const char *argv[])
    // Match the operation
    CmdL.DispatchArg(Cmds);
 
+   /// ??????????? 重复安装
+   //CmdLApp.DispatchArg(Cmds);
+
    // Print any errors or warnings found during parsing
    if (_error->empty() == false)
    {
diff --git a/cmdline/apt-shell.cc b/cmdline/apt-shell.cc
index 1508d84..734eb14 100644
--- a/cmdline/apt-shell.cc
+++ b/cmdline/apt-shell.cc
@@ -2650,6 +2650,7 @@ int main(int argc,const char *argv[])
 
    // Parse the command line and initialize the package library
    CommandLine CmdL(CommandArgs(""),_config);
+   /*
    if (pkgInitConfig(*_config) == false ||
        CmdL.Parse(argc,argv) == false ||
        pkgInitSystem(*_config,_system) == false)
@@ -2660,6 +2661,7 @@ int main(int argc,const char *argv[])
       _error->DumpErrors();
       return 100;
    }
+   */
 
    // Deal with stdout not being a tty
    if (ttyname(STDOUT_FILENO) == 0 && _config->FindI("quiet",0) < 1)
diff --git a/cmdline/cmdline.cc b/cmdline/cmdline.cc
index 59bf011..a2fb742 100644
--- a/cmdline/cmdline.cc
+++ b/cmdline/cmdline.cc
@@ -172,7 +172,7 @@ void SigWinch(int)
 // CacheFile::NameComp - QSort compare by name                          /*{{{*/
 // ---------------------------------------------------------------------
 /* */
-pkgCache *cmdCacheFile::SortCache = 0;
+//pkgCache *cmdCacheFile::SortCache = 0;
 int cmdCacheFile::NameComp(const void *a,const void *b)
 {
    if (*(pkgCache::Package **)a == 0 || *(pkgCache::Package **)b == 0)
@@ -189,7 +189,7 @@ int cmdCacheFile::NameComp(const void *a,const void *b)
 /* */
 void cmdCacheFile::Sort()
 {
-   delete [] List;
+   //delete [] List;
    List = new pkgCache::Package *[Cache->Head().PackageCount];
    memset(List,0,sizeof(*List)*Cache->Head().PackageCount);
    pkgCache::PkgIterator I = Cache->PkgBegin();
@@ -197,16 +197,654 @@ void cmdCacheFile::Sort()
       List[I->ID] = I;
 
    SortCache = *this;
-   qsort(List,Cache->Head().PackageCount,sizeof(*List),NameComp);
+   //qsort(List,Cache->Head().PackageCount,sizeof(*List),NameComp);
 }
 
 cmdCacheFile::~cmdCacheFile()
 {
    if (List) {
       delete [] List;
+      List = NULL;
    }
 }
 
+bool PkgInSys(const char *pkgName,pkgDepCache &CacheSys)
+{
+    pkgCache::PkgIterator Pkg = CacheSys.FindPkg(pkgName);
+    if (Pkg.end()) {
+        printf("\ntrace:%s,%d,[%s].\n",__FUNCTION__,__LINE__,"the end");
+        return false;
+    }
+    pkgDepCache::StateCache &State = CacheSys[Pkg];
+    //printf("\ntrace:%s,%d,end?[%s]State.Install()[%s].\n",__FUNCTION__,__LINE__,Pkg.end()?"end":"not end",State.Install()?"install":"not install");
+    if (CacheSys.MarkInstall(Pkg,true)) {
+        //return true;
+    }
+    //printf("\ntrace:%s,%d,pkgName[%s]State.Install()[%s].\n",__FUNCTION__,__LINE__,pkgName,State.Install()?"install":"not install");
+    return !State.Install();
+
+}
+
+/*
+*
+* 算法：
+1.先搜索isoft:
+    1.1 Pkg->CurrentVer 为0, 则isoft库没有安装此包，转到2.--------->或者/并且 povlist？？？？？todo...
+    1.2 Pkg->CurrentVer 不为0，安装了此包，不处理？
+2.再搜索sys:
+    2.1 Pkg->RevDepends 不为0,并且 Pkg->ProvidesList 不为0：
+    {
+        2.1.1 去掉包的左括号获取新包名，如果新包名和原来包名一致，说明sys安装了此包，通过.
+        2.1.2 新包名和原包名不一直，以此新包名，在系统库中搜索，
+        {
+            2.1.2.1 如果搜索不到，说明sys安装了此包，通过.
+            2.1.2.2 如果搜索到了，Pkg->RevDepends 不为0,并且 Pkg->ProvidesList 不为0，说明安装了此包，通过。
+        }
+    }
+*/
+bool CheckPkgInCache(pkgDepCache &Cache,const char *pkgName,bool reCheck)
+{
+    bool result = false;
+    for (pkgCache::PkgIterator Pkg = Cache.PkgBegin();
+         Pkg.end() == false; Pkg++)
+    {
+        if (strcmp(Pkg.Name(),pkgName) !=0)
+            continue;
+#if 0
+        printf("\ntrace:%s,%d,will check[%s]c[%x]s[%x]verlist[%x]||np[%x]revdep[%x],povlist[%x].count[%d]\n",__FUNCTION__,__LINE__,
+                       pkgName,Pkg->CurrentVer,Pkg->Section,Pkg->VersionList,
+                       Pkg->NextPackage,Pkg->RevDepends,Pkg->ProvidesList,Cache.Head().PackageCount);
+#endif
+        // only check in isoft
+        if (!reCheck) {
+            if (Pkg->CurrentVer != 0) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+//trace:CheckPkgInCache,254,will check[vim]c[b9c8]s[19d190]verlist[b9c8]||np[0]revdep[30176],povlist[25a1b].count[20504]
+        // to check in sys
+        // no.1 cur && pre, maybe in sys
+        if (Pkg->RevDepends != 0 && Pkg->ProvidesList != 0) {
+            result = true;
+            const char *p = strstr(pkgName,"(");
+            if (p == NULL) {
+                if (Pkg->VersionList == 0) {
+                    return true;
+                } else if (Pkg->CurrentVer != 0) {
+                    return true;
+                } else {
+                    return false;
+                }
+            } else {
+                bool find = false;
+                char newPkg[512]="";
+                snprintf(newPkg,p-pkgName +1,"%s",pkgName);
+                //printf("\ntrace:%s,%d,will check new pkg[%s].\n",__FUNCTION__,__LINE__,newPkg);
+
+                for (pkgCache::PkgIterator PkgSys = Cache.PkgBegin();
+                     PkgSys.end() == false; PkgSys++)
+                {
+                    if (strcmp(PkgSys.Name(),newPkg) !=0)
+                        continue;
+#if 0
+                    printf("\ntrace:%s,%d,will check[%s]c[%x]s[%x]verlist[%x]||np[%x]revdep[%x],povlist[%x].\n",__FUNCTION__,__LINE__,
+                                   newPkg,PkgSys->CurrentVer,PkgSys->Section,PkgSys->VersionList,
+                                   PkgSys->NextPackage,PkgSys->RevDepends,PkgSys->ProvidesList);
+#endif
+                    if (PkgSys->RevDepends != 0 && PkgSys->ProvidesList != 0) {
+                        return true;
+                    } else if (PkgSys->RevDepends == 0) {
+                        return false;
+                    } else {
+                        printf("\ntrace:%s,%d,pkg[%s],never go here!\n",__FUNCTION__,__LINE__,newPkg);
+                        return false;
+                    }
+                }
+                // can not find newpkg in sys, just return;
+                if (!find) {
+                    return true;
+                }
+
+            }
+        } else if (Pkg->RevDepends == 0) {
+            return false;
+        } else {
+            printf("\ntrace:%s,%d,pkg[%s],never go here!\n",__FUNCTION__,__LINE__,pkgName);
+            return false;
+        }
+    }
+
+    //printf("\ntrace:%s,%d,end.can not find pkg[%s]\n",__FUNCTION__,__LINE__,pkgName);
+
+    return result;
+}
+
+
+bool getPkgInstallState(cmdCacheFile &Cache,cmdCacheFile &CacheIsoft,const char *pkgName)
+{
+
+    //char pkgName[512]="";
+    //strcpy(pkgName,"/sbin/ldconfig");
+    bool isInIsoft = CheckPkgInCache(CacheIsoft,pkgName,false);
+    // pkg is in isoft, return;
+    if (isInIsoft) {
+        //printf("\ntrace:%s,%d,find pkg[%s] in isoft,installed.\n",__FUNCTION__,__LINE__,pkgName);
+        return isInIsoft;
+    }
+
+    // return the result:true--in sys; false--not installed.
+    isInIsoft = CheckPkgInCache(Cache,pkgName,true);
+    if(isInIsoft) {
+        //printf("\ntrace:%s,%d,find pkg[%s] in sys,installed.\n",__FUNCTION__,__LINE__,pkgName);
+    } else {
+        //printf("\ntrace:%s,%d,can find pkg[%s] in sys,not installed.\n",__FUNCTION__,__LINE__,pkgName);
+    }
+
+    return isInIsoft;
+}
+
+bool CheckPkgInCachex(pkgDepCache &Cache,const char *pkgName,bool reCheck)
+{
+     bool result = false;
+    for (pkgCache::PkgIterator Pkg = Cache.PkgBegin();
+         Pkg.end() == false; Pkg++)
+    {
+        if (strcmp(Pkg.Name(),pkgName) !=0)
+            continue;
+#if 0
+        //if(strcmp(pkgName,"librevenge") ==0)
+        printf("\ntrace:%s,%d,will check[%s]c[%x]s[%x]verlist[%x]||np[%x]revdep[%x],povlist[%x].count[%d][%s]\n",__FUNCTION__,__LINE__,
+                       pkgName,Pkg->CurrentVer,Pkg->Section,Pkg->VersionList,
+                       Pkg->NextPackage,Pkg->RevDepends,Pkg->ProvidesList,Cache.Head().PackageCount,reCheck?"re":"not re");
+#endif//
+        // only check in isoft
+        if (!reCheck) {
+            if (Pkg->CurrentVer != 0) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+        // to check in sys
+        // no.1 cur && pre, maybe in sys
+        if (Pkg->RevDepends != 0 && Pkg->ProvidesList != 0) {
+            result = true;
+            const char *p = strstr(pkgName,"(");
+            if (p == NULL) {
+                if (Pkg->VersionList == 0) {
+                    return true;
+                } else if (Pkg->CurrentVer != 0) {
+                    return true;
+                } else {
+                    return false;
+                }
+            } else {
+                bool find = false;
+                char newPkg[512]="";
+                snprintf(newPkg,p-pkgName +1,"%s",pkgName);
+                //printf("\ntrace:%s,%d,will check new pkg[%s].\n",__FUNCTION__,__LINE__,newPkg);
+
+                for (pkgCache::PkgIterator PkgSys = Cache.PkgBegin();
+                     PkgSys.end() == false; PkgSys++)
+                {
+                    if (strcmp(PkgSys.Name(),newPkg) !=0)
+                        continue;
+#if 0
+                    //if(strcmp(pkgName,"librevenge") ==0)
+                    printf("\ntrace:%s,%d,will check[%s]c[%x]s[%x]verlist[%x]||np[%x]revdep[%x],povlist[%x].\n",__FUNCTION__,__LINE__,
+                                   newPkg,PkgSys->CurrentVer,PkgSys->Section,PkgSys->VersionList,
+                                   PkgSys->NextPackage,PkgSys->RevDepends,PkgSys->ProvidesList);
+#endif
+                    if (PkgSys->CurrentVer == 0) {
+                        //printf("\ntrace:%s,%d.pkg[%s] not installed\n",__FUNCTION__,__LINE__,newPkg);
+                        return false;
+                    }if (PkgSys->RevDepends != 0 && PkgSys->ProvidesList != 0) {
+                        return true;
+                    } else if (PkgSys->RevDepends == 0) {
+                        return false;
+                    } else {
+                        printf("\ntrace:%s,%d,pkg[%s],never go here!\n",__FUNCTION__,__LINE__,newPkg);
+                        return false;
+                    }
+                }
+                // can not find newpkg in sys, just return;
+                if (!find) {
+                    return true;
+                }
+
+            }
+        } else if (Pkg->RevDepends == 0) {
+            return false;
+        } else {
+            printf("\ntrace:%s,%d,pkg[%s],never go here!\n",__FUNCTION__,__LINE__,pkgName);
+            return false;
+        }
+    }
+
+    //printf("\ntrace:%s,%d,end.can not find pkg[%s]\n",__FUNCTION__,__LINE__,pkgName);
+
+    return result;
+}
+bool getPkgInstallStatex(pkgDepCache &Cache,pkgDepCache &CacheIsoft,const char *pkgName)
+{
+    //char pkgName[512]="";
+    //strcpy(pkgName,"/sbin/ldconfig");
+    bool isInIsoft = CheckPkgInCachex(CacheIsoft,pkgName,false);
+    // pkg is in isoft, return;
+    if (isInIsoft) {
+        //printf("\ntrace:%s,%d,find pkg[%s] in isoft,installed.\n",__FUNCTION__,__LINE__,pkgName);
+        return isInIsoft;
+    }
+
+    // return the result:true--in sys; false--not installed.
+    isInIsoft = CheckPkgInCachex(Cache,pkgName,true);
+    if(isInIsoft) {
+        //printf("\ntrace:%s,%d,find pkg[%s] in sys,installed.\n",__FUNCTION__,__LINE__,pkgName);
+    } else {
+        //printf("\ntrace:%s,%d,can find pkg[%s] in sys,not installed.\n",__FUNCTION__,__LINE__,pkgName);
+    }
+
+    return isInIsoft;
+
+}
+
+/*
+* just like ShowBroken()
+* added: pkg which is broken will be checked in sys cache(CacheSys),to find out is it installed or not.
+*/
+void ShowBrokenCheck(ostream &out,cmdCacheFile &Cache,bool Now,pkgDepCache &CacheSys)
+{
+    return ;// test
+    bool OnlyPrintOnePkg = true;
+    //no.1 out << _("The following packages have unmet dependencies:") << endl;
+    for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+    {
+       pkgCache::PkgIterator I(Cache,Cache.List[J]);
+       if (Now == true)
+       {
+          if (Cache[I].NowBroken() == false)
+             continue;
+       }
+       else
+       {
+          if (Cache[I].InstBroken() == false)
+             continue;
+       }
+
+       // Print out each package and the failed dependencies
+       // no.2 out <<"  " <<  I.Name() << ":";
+       OnlyPrintOnePkg = true; // will be set to true when pkg changed.
+       size_t Indent = strlen(I.Name()) + 3;
+       bool First = true;
+       pkgCache::VerIterator Ver;
+
+       if (Now == true)
+          Ver = I.CurrentVer();
+       else
+          Ver = Cache[I].InstVerIter(Cache);
+
+       if (Ver.end() == true)
+       {
+          out << endl;
+          continue;
+       }
+
+       // no.1 & no.2 will be do only once.
+       bool OnlyPrintOne = true;
+
+       for (pkgCache::DepIterator D = Ver.DependsList(); D.end() == false;)
+       {
+          // Compute a single dependency element (glob or)
+          pkgCache::DepIterator Start;
+          pkgCache::DepIterator End;
+          D.GlobOr(Start,End);
+
+          // CNC:2003-02-22 - IsImportantDep() currently calls IsCritical(), so
+          //		     these two are currently doing the same thing. Check
+          //		     comments in IsImportantDep() definition.
+ #if 0
+          if (Cache->IsImportantDep(End) == false)
+             continue;
+ #else
+          if (End.IsCritical() == false)
+             continue;
+ #endif
+
+          if (Now == true)
+          {
+             if ((Cache[End] & pkgDepCache::DepGNow) == pkgDepCache::DepGNow)
+                continue;
+          }
+          else
+          {
+             if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
+                continue;
+          }
+
+          bool FirstOr = true;
+          while (1)
+          {
+              /* the following are added --begin--*/
+              // to check if this pkg is installed or not in sys cache
+              if (PkgInSys("libtomcrypt(x86-64)",CacheSys) ) {
+                  //if(strstr(Start.TargetPkg().Name(),"libtomcrypt"))
+                    printf("\ntrace:%s,%d,pkg[%s] has been installed in sys.\n",__FUNCTION__,__LINE__,Start.TargetPkg().Name());
+
+                  return;
+
+                  if (Start == End)
+                     break;
+
+                  Start++;
+
+                  continue;
+              } else {
+                    printf("\ntrace:%s,%d,pkg[%s] .....\n",__FUNCTION__,__LINE__,Start.TargetPkg().Name());
+              }
+
+
+              if (OnlyPrintOne) {
+                  OnlyPrintOne = false;
+                  out << _("The following packages have unmet dependencies:") << endl;
+              }
+              if (OnlyPrintOnePkg) {
+                  OnlyPrintOnePkg = false;
+                  out <<"  " <<  I.Name() << ":";
+              }
+              /* the following are added --end--*/
+
+
+             if (First == false)
+                for (unsigned J = 0; J != Indent; J++)
+                   out << ' ';
+             First = false;
+
+             if (FirstOr == false)
+             {
+                for (size_t J = 0; J != strlen(End.DepType()) + 3; J++)
+                   out << ' ';
+             }
+             else
+                out << ' ' << End.DepType() << ": ";
+             FirstOr = false;
+
+             out << Start.TargetPkg().Name();
+
+             // Show a quick summary of the version requirements
+             if (Start.TargetVer() != 0)
+                out << " (" << Start.CompType() << " " << Start.TargetVer() << ")";
+
+             /* Show a summary of the target package if possible. In the case
+                of virtual packages we show nothing */
+             pkgCache::PkgIterator Targ = Start.TargetPkg();
+             if (Targ->ProvidesList == 0)
+             {
+                out << ' ';
+                pkgCache::VerIterator Ver = Cache[Targ].InstVerIter(Cache);
+                if (Now == true)
+                   Ver = Targ.CurrentVer();
+
+                if (Ver.end() == false)
+                {
+                   if (Now == true)
+                      ioprintf(out,_("but %s is installed"),Ver.VerStr());
+                   else
+                      ioprintf(out,_("but %s is to be installed"),Ver.VerStr());
+                }
+                else
+                {
+                   if (Cache[Targ].CandidateVerIter(Cache).end() == true)
+                   {
+                      if (Targ->ProvidesList == 0)
+                         out << _("but it is not installable");
+                      else
+                         out << _("but it is a virtual package");
+                   }
+                   else
+                      out << (Now?_("but it is not installed"):_("but it is not going to be installed"));
+                }
+             }
+
+             if (Start != End)
+                out << _(" or");
+             out << endl;
+
+             if (Start == End)
+                break;
+             Start++;
+          }
+       }
+    }
+    return;
+}
+
+void ShowBrokenCheck3(cmdCacheFile &Cache,cmdCacheFile &Cache2)
+{
+
+    for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+    {
+       pkgCache::PkgIterator I(Cache,Cache.List[J]);
+
+       pkgCache::VerIterator Ver;
+
+       if(strstr(I.Name(),"librevenge") ==NULL)
+           continue;
+
+       printf("\ntrace:%s,%d,pkg name[%s]\n",__FUNCTION__,__LINE__,I.Name());
+
+
+       for (pkgCache::PrvIterator P = I.ProvidesList(); P.end() == false; P++)
+       {
+           pkgCache::PkgIterator PPkg = P.OwnerPkg();
+           printf("\ntrace:%s,%d,pkg name[%s]-->p[%s]\n",__FUNCTION__,__LINE__,I.Name(),PPkg.Name());
+
+       }
+
+
+    }
+
+    return;
+}
+
+void ShowBrokenNew(ostream &out,cmdCacheFile &Cache,cmdCacheFile &CacheSys)
+{
+    bool Now = true; //default is true
+    bool firstPrint = true;
+    char printStr[16]="";
+    char baseStr[]="Checking";
+    int  printStrLen = 0;
+    time_t currtime = time(NULL);
+
+    for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+    {
+        if (firstPrint) {
+            time_t now = time(NULL);
+            if ((now - currtime ) > 1) {
+                printStrLen ++;
+                if(printStrLen > 6) {
+                    printStrLen = 1;
+                    memset(printStr,0,sizeof(printStr));
+                }
+                memset(printStr,' ',sizeof(printStr)-1);
+                memset(printStr,'.',printStrLen);
+                //printf("\r%s%s",baseStr,printStr);
+                out << "\r" << baseStr << printStr;
+                fflush(stdout);
+            }
+        }
+
+       pkgCache::PkgIterator I(Cache,Cache.List[J]);
+
+       if (Now == true)
+       {
+          if (Cache[I].NowBroken() == false)
+             continue;
+       }
+       else
+       {
+          if (Cache[I].InstBroken() == false)
+             continue;
+       }
+
+       // Print out each package and the failed dependencies
+
+       int displayName = -1; // -1--init;1--ok;0--not;
+
+       size_t Indent = strlen(I.Name()) + 3;
+       bool First = true;
+       pkgCache::VerIterator Ver;
+
+       if (Now == true)
+          Ver = I.CurrentVer();
+       else
+          Ver = Cache[I].InstVerIter(Cache);
+
+       if (Ver.end() == true)
+       {
+          out << endl;
+          continue;
+       }
+       //bool FirstOr = true;
+
+       for (pkgCache::DepIterator D = Ver.DependsList(); D.end() == false;)
+       {
+          // Compute a single dependency element (glob or)
+          pkgCache::DepIterator Start;
+          pkgCache::DepIterator End;
+          D.GlobOr(Start,End);
+
+          // CNC:2003-02-22 - IsImportantDep() currently calls IsCritical(), so
+          //		     these two are currently doing the same thing. Check
+          //		     comments in IsImportantDep() definition.
+ #if 0
+          if (Cache->IsImportantDep(End) == false)
+             continue;
+ #else
+          if (End.IsCritical() == false)
+             continue;
+ #endif
+
+          if (Now == true)
+          {
+             if ((Cache[End] & pkgDepCache::DepGNow) == pkgDepCache::DepGNow)
+                continue;
+          }
+          else
+          {
+             if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
+                continue;
+          }
+
+          bool FirstOr = true;
+          while (1)
+          {
+              if(getPkgInstallStatex(CacheSys,Cache,Start.TargetPkg().Name())) {
+
+                  //out << "ok:" << Start.TargetPkg().Name();
+                  if (Start == End)
+                     break;
+                  Start++;
+                  continue;
+              } else {
+                  if (displayName ==  -1) {
+                    displayName = 1;
+                  } else {
+                      displayName = 0;
+                  }
+              }
+
+             if (displayName == 1) {
+                 //c1out << _("You might want to run `apt-get --fix-broken install' to correct these.") << endl;
+
+                 if (firstPrint) {
+                     out << endl << _("The following packages have unmet dependencies:") << endl;
+                     firstPrint = false;
+                 }
+                  out <<"  " <<  I.Name() << ":";
+
+                  displayName = 0;
+             }
+
+             if (displayName == 0) {
+
+             if (First == false)
+                for (unsigned J = 0; J != Indent; J++)
+                   out << ' ';
+             First = false;
+
+             if (FirstOr == false)
+             {
+                for (size_t J = 0; J != strlen(End.DepType()) + 3; J++)
+                   out << ' ';
+             }
+             else
+                out << ' ' << End.DepType() << ": ";
+             FirstOr = false;
+
+             out << Start.TargetPkg().Name();
+
+             // Show a quick summary of the version requirements
+             if (Start.TargetVer() != 0)
+                out << " (" << Start.CompType() << " " << Start.TargetVer() << ")";
+
+             out << ' ';
+
+             out << _("but it is not installable");
+
+             /* Show a summary of the target package if possible. In the case
+                of virtual packages we show nothing */
+             pkgCache::PkgIterator Targ = Start.TargetPkg();
+             if (Targ->ProvidesList == 0)
+             {
+                out << ' ';
+                pkgCache::VerIterator Ver = Cache[Targ].InstVerIter(Cache);
+                if (Now == true)
+                   Ver = Targ.CurrentVer();
+
+                if (Ver.end() == false)
+                {
+                   if (Now == true)
+                      ioprintf(out,_("but %s is installed"),Ver.VerStr());
+                   else
+                      ioprintf(out,_("but %s is to be installed"),Ver.VerStr());
+                }
+                else
+                {
+                   if (Cache[Targ].CandidateVerIter(Cache).end() == true)
+                   {
+                      if (Targ->ProvidesList == 0)
+                         out << _("but it is not installable");
+                      else
+                         out << _("but it is a virtual package");
+                   }
+                   else
+                      out << (Now?_("but it is not installed"):_("but it is not going to be installed"));
+                }
+             }
+
+             if (Start != End)
+                out << _(" or");
+             out << endl;
+
+             if (Start == End)
+                break;
+             Start++;
+
+             } // if (displayName == 1) {
+          } // while(1)
+       } // for (pkgCache::DepIterator D = Ver.DependsList(); D.end() == false;)
+
+    } // for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+
+
+    out << _("Done.") << endl;
+
+    return ;//_error->Error(_("Unmet dependencies. Try using --fix-broken."));
+
+}
+
 // ShowBroken - Debugging aide						/*{{{*/
 // ---------------------------------------------------------------------
 /* This prints out the names of all the packages that are broken along
@@ -281,7 +919,7 @@ void ShowBroken(ostream &out,cmdCacheFile &Cache,bool Now,pkgDepCache::State *St
 	 {
 	    if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
 	       continue;
-	 }
+         }
 	 
 	 bool FirstOr = true;
 	 while (1)
@@ -300,7 +938,7 @@ void ShowBroken(ostream &out,cmdCacheFile &Cache,bool Now,pkgDepCache::State *St
 	       out << ' ' << End.DepType() << ": ";
 	    FirstOr = false;
 	    
-	    out << Start.TargetPkg().Name();
+            out << Start.TargetPkg().Name();
 	 
 	    // Show a quick summary of the version requirements
 	    if (Start.TargetVer() != 0)
@@ -341,8 +979,8 @@ void ShowBroken(ostream &out,cmdCacheFile &Cache,bool Now,pkgDepCache::State *St
 	       out << _(" or");
 	    out << endl;
 	    
-	    if (Start == End)
-	       break;
+            if (Start == End)
+               break;
 	    Start++;
 	 }	 
       }	    
diff --git a/cmdline/cmdline.h b/cmdline/cmdline.h
index 4bacf8c..c1e1233 100644
--- a/cmdline/cmdline.h
+++ b/cmdline/cmdline.h
@@ -29,14 +29,15 @@ const char *op2str(int op);
 
 class cmdCacheFile : public pkgCacheFile
 {
-   static pkgCache *SortCache;
-   static int NameComp(const void *a,const void *b);
+   pkgCache *SortCache;
+   int NameComp(const void *a,const void *b);
 
    public:
    pkgCache::Package **List;
    void Sort();
 
-   cmdCacheFile() : List(0) {}
+   //cmdCacheFile() : List(0) {}
+   cmdCacheFile(bool useIsoft = false) : pkgCacheFile(useIsoft) {}
    virtual ~cmdCacheFile();
 };
 
@@ -93,5 +94,10 @@ bool cmdSearchFile(CommandLine &CmdL, pkgCache &Cache);
 bool cmdFileList(CommandLine &CmdL, pkgCache &Cache);
 bool cmdChangeLog(CommandLine &CmdL, pkgCache &Cache);
 
-
+bool PkgInSys(const char *pkgName,pkgDepCache &CacheSys);
+void ShowBrokenCheck(ostream &out,cmdCacheFile &Cache,bool Now,
+                pkgDepCache &CacheSys);
+void ShowBrokenNew(ostream &out,cmdCacheFile &Cache,cmdCacheFile &CacheIsoft);
+bool getPkgInstallState(cmdCacheFile &Cache,cmdCacheFile &CacheIsoft,const char *pkgName);
+void ShowBrokenCheck3(cmdCacheFile &Cache,cmdCacheFile &Cache2);
 // vim:sts=3:sw=3
diff --git a/configure.ac b/configure.ac
index ec699b6..864a042 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 dnl Process this file with autoconf to produce a configure script.
 
 AC_PREREQ(2.59)
-AC_INIT([apt],[0.5.15lorg3.95],[apt-rpm@lists.laiskiainen.org])
+AC_INIT([isoftapp],[0.5.15lorg3.95],[apt-rpm@lists.laiskiainen.org])
 dnl Check the archs, we want the target type.
 AC_CONFIG_AUX_DIR([buildlib])
 AC_CONFIG_MACRO_DIR([m4])
@@ -23,6 +23,15 @@ AC_PROG_CPP
 
 AC_PROG_LIBTOOL
 
+AC_ARG_ENABLE(debug,
+              [AS_HELP_STRING([--enable-debug=@<:@no/yes@:>@],
+                              [turn on debugging [default=no]])],,
+              [enable_debug=no])
+
+if test "x$enable_debug" = "xyes"; then
+  test "$cppflags_set" = set || CPPFLAGS="$CPPFLAGS -g -DAPT_RPM_DEBUG"
+fi
+
 dnl Checks for sockets
 SAVE_LIBS="$LIBS"
 LIBS=""
@@ -236,7 +245,6 @@ dnl AC_PATH_PROG(DEBIANDOC_TEXT,debiandoc2text)
 AC_PATH_PROG([GPG],[gpg],[/usr/bin/gpg])
 
 AM_GNU_GETTEXT_VERSION([0.14.5])
-AM_GNU_GETTEXT([external])
 
 dnl ah_NUM_PROCS
 dnl rc_GLIBC_VER
@@ -253,7 +261,6 @@ AC_CONFIG_FILES([
 	  tools/Makefile
 	  doc/Makefile
 	  test/Makefile
-	  po/Makefile.in
 	  ])
 AC_CONFIG_LINKS([include/apti18n.h:buildlib/gettext.h])
 
diff --git a/methods/Makefile.am b/methods/Makefile.am
index 151a3e5..1c54859 100644
--- a/methods/Makefile.am
+++ b/methods/Makefile.am
@@ -1,6 +1,6 @@
 AM_CPPFLAGS = -DGPG=\"@GPG@\"
 
-methodsdir=${libdir}/apt/methods
+methodsdir=${libdir}/isoftapp/methods
 methods_PROGRAMS = cdrom copy file ftp gpg gzip bzip2 http rsh ssh
 
 LDADD = ../apt-pkg/libapt-pkg.la
diff --git a/test/scratch.cc b/test/scratch.cc
index 5256e3f..b06e28d 100644
--- a/test/scratch.cc
+++ b/test/scratch.cc
@@ -8,7 +8,7 @@ using namespace std;
 
 int main(int argc,char *argv[])
 {
-   pkgInitConfig(*_config);
+   //pkgInitConfig(*_config);
    pkgInitSystem(*_config,_system);
 
    // do something... 
