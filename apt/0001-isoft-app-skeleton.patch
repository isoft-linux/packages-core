diff --git a/apt-pkg/cachefile.cc b/apt-pkg/cachefile.cc
index 6b13d81..c58bb44 100644
--- a/apt-pkg/cachefile.cc
+++ b/apt-pkg/cachefile.cc
@@ -22,12 +22,16 @@
     
 #include <apti18n.h>
 									/*}}}*/
+bool g_useIsoftApp = false;
 
 // CacheFile::CacheFile - Constructor					/*{{{*/
 // ---------------------------------------------------------------------
 /* */
-pkgCacheFile::pkgCacheFile() : Map(0), Cache(0), DCache(0), Policy(0)
+//pkgCacheFile::pkgCacheFile() : Map(0), Cache(0), DCache(0), Policy(0)
+pkgCacheFile::pkgCacheFile(bool useIsoft) : Map(0), Cache(0), DCache(0), Policy(0)
 {
+   m_useIsoft = useIsoft;
+   g_useIsoftApp = useIsoft;
 }
 									/*}}}*/
 // CacheFile::~CacheFile - Destructor					/*{{{*/
@@ -48,7 +52,7 @@ pkgCacheFile::~pkgCacheFile()
 bool pkgCacheFile::BuildCaches(OpProgress &Progress,bool WithLock)
 {
    if (WithLock == true)
-      if (_system->Lock() == false)
+      if (_system->Lock(m_useIsoft) == false)
 	 return false;
 
    // CNC:2002-07-06
diff --git a/apt-pkg/cachefile.h b/apt-pkg/cachefile.h
index 036df2e..4131739 100644
--- a/apt-pkg/cachefile.h
+++ b/apt-pkg/cachefile.h
@@ -45,9 +45,11 @@ class pkgCacheFile
    bool BuildCaches(OpProgress &Progress,bool WithLock = true);
    bool Open(OpProgress &Progress,bool WithLock = true);
    void Close();
-   
-   pkgCacheFile();
+
+   pkgCacheFile(bool useIsoft = false);   
    ~pkgCacheFile();
+   private:
+   bool m_useIsoft;
 };
 
 #endif
diff --git a/apt-pkg/depcache.cc b/apt-pkg/depcache.cc
index 95415ca..2970aa7 100644
--- a/apt-pkg/depcache.cc
+++ b/apt-pkg/depcache.cc
@@ -230,7 +230,8 @@ bool pkgDepCache::CheckDep(DepIterator Dep,int Type,PkgIterator &Res)
 	    break;
 
 	 case InstallVersion:
-	    if (PkgState[Pkg->ID].InstallVer != 0)
+	    // TODO: check dependes
+        if (PkgState[Pkg->ID].InstallVer != 0)
 	       if (VS.CheckDep(PkgState[Pkg->ID].InstVerIter(*this).VerStr(),
 				       Dep) == true)
 		  return true;
diff --git a/apt-pkg/packagemanager.cc b/apt-pkg/packagemanager.cc
index e0e4f8a..ca40485 100644
--- a/apt-pkg/packagemanager.cc
+++ b/apt-pkg/packagemanager.cc
@@ -672,6 +672,9 @@ pkgPackageManager::OrderResult pkgPackageManager::DoInstall(InstProgress *Prog)
 									/*}}}*/
 pkgPackageManager::OrderResult pkgPackageManager::DoInstall()
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    InstProgress *Prog;
    pkgPackageManager::OrderResult res;
    if (_config->FindB("RPM::Interactive",true)) {
diff --git a/apt-pkg/pkgsystem.h b/apt-pkg/pkgsystem.h
index 2ac0893..b4b2e80 100644
--- a/apt-pkg/pkgsystem.h
+++ b/apt-pkg/pkgsystem.h
@@ -62,7 +62,8 @@ class pkgSystem
    
    /* Prevent other programs from touching shared data not covered by
       other locks (cache or state locks) */
-   virtual bool Lock() = 0;
+   //virtual bool Lock() = 0;
+   virtual bool Lock(bool useIsoft = false) = 0;
    virtual bool UnLock(bool NoErrors = false) = 0;
 
    // CNC:2002-07-06
diff --git a/apt-pkg/rpm/rpmhandler.cc b/apt-pkg/rpm/rpmhandler.cc
index 0b600d3..0287e0a 100644
--- a/apt-pkg/rpm/rpmhandler.cc
+++ b/apt-pkg/rpm/rpmhandler.cc
@@ -62,6 +62,10 @@ bool HideZeroEpoch;
 
 static rpmds rpmlibProv = NULL;
 
+#define ISOFTAPP_DIR "/var/lib/isoft-app"
+#define SYSAPP_DIR "/var/lib/rpm"
+extern bool g_useIsoftApp;
+
 string RPMHandler::EVR() const
 {
    string e = Epoch();
@@ -545,9 +549,17 @@ string RPMDirHandler::HashType() const
    return "MD5-Hash";
 }
  
-RPMDBHandler::RPMDBHandler(bool WriteLock)
+RPMDBHandler::RPMDBHandler(bool WriteLock,bool useIsoftApp)
    : Handler(0), WriteLock(WriteLock)
 {
+   g_useIsoftApp = useIsoftApp;
+
+   if (useIsoftApp) {
+       rpmtsSetMacro(ISOFTAPP_DIR);
+   } else {
+       rpmtsSetMacro(SYSAPP_DIR);
+   }
+
    RpmIter = NULL;
    string Dir = _config->Find("RPM::RootDir", "/");
    
@@ -566,7 +578,14 @@ RPMDBHandler::RPMDBHandler(bool WriteLock)
 
    Handler = rpmtsCreate();
    rpmtsSetVSFlags(Handler, (rpmVSFlags_e)-1);
-   rpmtsSetRootDir(Handler, Dir.c_str());
+   if (useIsoftApp) {
+      rpmtsSetRootDir(Handler, Dir.c_str());
+      rpmtsSetMacro(ISOFTAPP_DIR);
+   }
+   else {
+      rpmtsSetRootDir(Handler, Dir.c_str());
+      rpmtsSetMacro(SYSAPP_DIR);
+   }
 
    RpmIter = raptInitIterator(Handler, RPMDBI_PACKAGES, NULL, 0);
    if (RpmIter == NULL) {
@@ -630,6 +649,8 @@ string RPMDBHandler::DataPath(bool DirectoryOnly)
    string File = "Packages";
    char *tmp = (char *) rpmExpand("%{_dbpath}", NULL);
    string DBPath(_config->Find("RPM::RootDir")+tmp);
+   // TODO: here need to modify if not ok.
+
    free(tmp);
 
    if (DirectoryOnly == true)
@@ -943,6 +964,9 @@ string RPMRepomdHandler::SourceRpm() const
 
 bool RPMRepomdHandler::PRCO(unsigned int Type, vector<Dependency*> &Deps) const
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    xmlNode *format = XmlFindNode(NodeP, "format");
    xmlNode *prco = NULL;
 
@@ -1401,6 +1425,9 @@ string RPMSqliteHandler::HashType() const
 
 bool RPMSqliteHandler::PRCO(unsigned int Type, vector<Dependency*> &Deps) const
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    SqliteQuery *prco = NULL;
    switch (Type) {
       case pkgCache::Dep::Depends:
diff --git a/apt-pkg/rpm/rpmhandler.h b/apt-pkg/rpm/rpmhandler.h
index 6014a1c..264864b 100644
--- a/apt-pkg/rpm/rpmhandler.h
+++ b/apt-pkg/rpm/rpmhandler.h
@@ -225,7 +225,8 @@ class RPMDBHandler : public RPMHdrHandler
    // used by rpmSystem::DistroVer()
    bool JumpByName(string PkgName, bool Provides=false);
 
-   RPMDBHandler(bool WriteLock=false);
+   //RPMDBHandler(bool WriteLock=false);
+   RPMDBHandler(bool WriteLock=false,bool useIsoftApp=false);
    virtual ~RPMDBHandler();
 };
 
diff --git a/apt-pkg/rpm/rpmlistparser.cc b/apt-pkg/rpm/rpmlistparser.cc
index 749c91e..ed327a3 100644
--- a/apt-pkg/rpm/rpmlistparser.cc
+++ b/apt-pkg/rpm/rpmlistparser.cc
@@ -283,6 +283,7 @@ unsigned short rpmListParser::VersionHash()
 bool rpmListParser::ParseStatus(pkgCache::PkgIterator Pkg,
 				pkgCache::VerIterator Ver)
 {   
+   // TODO: CurrentVer
    if (!Handler->IsDatabase())  // this means we're parsing an hdlist, so it's not installed
       return true;
    
@@ -448,6 +449,7 @@ off_t rpmListParser::Size()
 // Allow-Duplicated rules.
 void rpmListParser::VirtualizePackage(string Name)
 {
+   // TODO: CurrentVer
    pkgCache::PkgIterator FromPkgI = Owner->GetCache().FindPkg(Name);
 
    // Should always be false
diff --git a/apt-pkg/rpm/rpmpm.cc b/apt-pkg/rpm/rpmpm.cc
index 1271ea4..1814fba 100644
--- a/apt-pkg/rpm/rpmpm.cc
+++ b/apt-pkg/rpm/rpmpm.cc
@@ -398,7 +398,7 @@ bool pkgRPMExtPM::ExecRPM(Item::RPMOps op, vector<const char*> &files)
    switch (op)
    {
       case Item::RPMInstall:
-	 if (Interactive)
+     if (Interactive)
 	    operation = "-ivh";
 	 else
 	    operation = "-iv";
@@ -637,6 +637,9 @@ bool pkgRPMExtPM::Process(vector<const char*> &install,
 			  vector<const char*> &upgrade,
 			  vector<const char*> &uninstall)
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    if (uninstall.empty() == false)
        ExecRPM(Item::RPMErase, uninstall);
    if (install.empty() == false)
@@ -676,13 +679,16 @@ bool pkgRPMLibPM::AddToTransaction(Item::RPMOps op, vector<const char*> &files)
 	 case Item::RPMUpgrade:
 	    upgrade = 1;
 	 case Item::RPMInstall:
+#ifdef APT_RPM_DEBUG
+        std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << " " << std::string(*I) << std::endl;
+#endif
 	    fd = Fopen(*I, "r.ufdio");
 	    if (fd == NULL)
 	       _error->Error(_("Failed opening %s"), *I);
             rc = rpmReadPackageFile(TS, fd, *I, &hdr);
 	    if (rc != RPMRC_OK && rc != RPMRC_NOTTRUSTED && rc != RPMRC_NOKEY)
 	       _error->Error(_("Failed reading file %s"), *I);
-	    rc = rpmtsAddInstallElement(TS, hdr, *I, upgrade, 0);
+        rc = rpmtsAddInstallElement(TS, hdr, *I, upgrade, 0);
 	    if (rc)
 	       _error->Error(_("Failed adding %s to transaction %s"),
 			     *I, "(install)");
@@ -714,6 +720,9 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
 			  vector<const char*> &upgrade,
 			  vector<const char*> &uninstall)
 {
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << std::endl;
+#endif
    int rc = 0;
    bool Success = false;
    bool Interactive = _config->FindB("RPM::Interactive",true);
@@ -760,7 +769,7 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
        AddToTransaction(Item::RPMUpgrade, upgrade);
 
    if (_config->FindB("RPM::NoDeps", false) == false) {
-      rc = rpmtsCheck(TS);
+      rc = rpmtsCheckISoftApp(TS);
       probs = rpmtsProblems(TS);
       if (rc || rpmpsNumProblems(probs) > 0) {
 	 rpmpsPrint(NULL, probs);
@@ -785,7 +794,7 @@ bool pkgRPMLibPM::Process(vector<const char*> &install,
    rpmtsSetFlags(TS, (rpmtransFlags)(rpmtsFlags(TS) | tsFlags));
    rpmtsClean(TS);
    rc = rpmtsSetNotifyCallback(TS, rpmCallback, Progress);
-   rc = rpmtsRun(TS, NULL, (rpmprobFilterFlags)probFilter);
+   rc = rpmtsRunISoftApp(TS, NULL, (rpmprobFilterFlags)probFilter);
    probs = rpmtsProblems(TS);
 
    if (rc > 0) {
diff --git a/apt-pkg/rpm/rpmsystem.cc b/apt-pkg/rpm/rpmsystem.cc
index 86d0f17..0397103 100644
--- a/apt-pkg/rpm/rpmsystem.cc
+++ b/apt-pkg/rpm/rpmsystem.cc
@@ -64,8 +64,10 @@ rpmSystem::~rpmSystem()
 
 RPMDBHandler *rpmSystem::GetDBHandler()
 {
-   if (RpmDB == NULL)
-      RpmDB = new RPMDBHandler();
+   if (RpmDB == NULL) {
+      RpmDB = new RPMDBHandler(false,m_IsoftApp);
+      //RpmDB = new RPMDBHandler();
+   }
    return RpmDB;
 }
 
@@ -82,15 +84,20 @@ bool rpmSystem::LockRead()
 // System::Lock - Get the lock						/*{{{*/
 // ---------------------------------------------------------------------
 /* this will open the rpm database through rpmlib, which will lock the db */
-bool rpmSystem::Lock()
+//bool rpmSystem::Lock()
+bool rpmSystem::Lock(bool useIsoft)
 {
+   m_IsoftApp = useIsoft;
+
    if (RpmDB != NULL && RpmDB->HasWriteLock() == false)
    {
       delete RpmDB;
       RpmDB = NULL;
    }
-   if (RpmDB == NULL)
-      RpmDB = new RPMDBHandler(true);
+   if (RpmDB == NULL) {
+      RpmDB = new RPMDBHandler(true,m_IsoftApp);
+      //RpmDB = new RPMDBHandler(true);
+   }
    if (_error->PendingError() == true)
       return false;
    LockCount++;
diff --git a/apt-pkg/rpm/rpmsystem.h b/apt-pkg/rpm/rpmsystem.h
index 53629be..66f62fb 100644
--- a/apt-pkg/rpm/rpmsystem.h
+++ b/apt-pkg/rpm/rpmsystem.h
@@ -26,6 +26,7 @@ class rpmSystem : public pkgSystem
    int LockCount;
    RPMDBHandler *RpmDB;
    rpmDatabaseIndex *StatusFile;
+   bool m_IsoftApp;
    
    bool processIndexFile(rpmIndexFile *Handler,OpProgress &Progress);
    
@@ -34,7 +35,8 @@ class rpmSystem : public pkgSystem
    RPMDBHandler *GetDBHandler();
    
    virtual bool LockRead();
-   virtual bool Lock();
+   //virtual bool Lock();
+   virtual bool Lock(bool useIsoft = false);
    virtual bool UnLock(bool NoErrors = false);
    virtual pkgPackageManager *CreatePM(pkgDepCache *Cache) const;
    virtual bool Initialize(Configuration &Cnf);
diff --git a/cmdline/apt-get.cc b/cmdline/apt-get.cc
index b755f49..5647966 100644
--- a/cmdline/apt-get.cc
+++ b/cmdline/apt-get.cc
@@ -68,6 +68,9 @@
     
 									/*}}}*/
 
+/********** use isoftapp or not ************/
+#define USEISOFTAPP
+
 using namespace std;
 
 ostream c0out(0);
@@ -83,6 +86,7 @@ unsigned int ScreenWidth = 80;
 class CacheFile : public cmdCacheFile
 {
    public:
+   bool m_useIsoft = false;
    bool CheckDeps(bool AllowBroken = false);
    bool BuildCaches(bool WithLock = true)
    {
@@ -109,7 +113,8 @@ class CacheFile : public cmdCacheFile
       else
 	 return Open(true);
    }
-   CacheFile() : cmdCacheFile() {}
+   //CacheFile() : cmdCacheFile() {}
+   CacheFile(bool useIsoft = false) : cmdCacheFile(useIsoft) {m_useIsoft = useIsoft;}
 };
 									/*}}}*/
 
@@ -724,6 +729,9 @@ bool TryToInstall(pkgCache::PkgIterator Pkg,pkgDepCache &Cache,
    
    // Check if there is something at all to install
    pkgDepCache::StateCache &State = Cache[Pkg];
+#ifdef APT_RPM_DEBUG
+   std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << " " << Pkg->CurrentVer << std::endl;
+#endif
    if (Remove == true && Pkg->CurrentVer == 0)
    {
       Fix.Clear(Pkg);
@@ -1074,12 +1082,459 @@ bool DoUpgrade(CommandLine &CmdL)
    return InstallPackages(Cache,true);
 }
 									/*}}}*/
+/*
+* 1.create new cache by /var/lib/isoft-app
+* 2.do the same thing like DoInstall()
+*/
+bool tryNewCache(const char *pkgName,CommandLine &CmdL)
+{
+    CacheFile Cache(true);
+
+    if (Cache.OpenForInstall() == false ||
+        Cache.CheckDeps(CmdL.FileSize() != 1) == false)
+       return false;
+
+   // #############################begin xxxxxx#######################################
+
+   // Enter the special broken fixing mode if the user specified arguments
+   bool BrokenFix = false;
+   if (Cache->BrokenCount() != 0)
+      BrokenFix = true;
+   
+   unsigned int ExpectedInst = 0;
+   unsigned int Packages = 0;
+   pkgProblemResolver Fix(Cache);
+   
+   bool DefRemove = false;
+   if (strcasecmp(CmdL.FileList[0],"remove") == 0)
+      DefRemove = true;
+   // CNC:2004-03-22
+   else if (strcasecmp(CmdL.FileList[0],"reinstall") == 0)
+      _config->Set("APT::Get::ReInstall", true);
+
+   for (const char **I = CmdL.FileList + 1; *I != 0; I++)
+   {
+      // Duplicate the string
+      size_t Length = strlen(*I);
+      char S[300];
+      if (Length >= sizeof(S))
+	 continue;
+      strcpy(S,*I);
+
+      // CNC:2003-03-15
+      char OrigS[300];
+      strcpy(OrigS,S);
+
+      // See if we are removing and special indicators..
+      bool Remove = DefRemove;
+      char *VerTag = 0;
+      bool VerIsRel = false;
+      // CNC:2003-11-05
+      int VerOp = 0;
+      while (Cache->FindPkg(S).end() == true)
+      {
+	 // Handle an optional end tag indicating what to do
+	 if (Length >= 1 && S[Length - 1] == '-')
+	 {
+	    Remove = true;
+	    S[--Length] = 0;
+	    continue;
+	 }
+	 
+	 if (Length >= 1 && S[Length - 1] == '+')
+	 {
+	    Remove = false;
+	    S[--Length] = 0;
+	    continue;
+	 }
+	 
+	 // CNC:2003-11-05
+	 char *sep = strpbrk(S,"=><");
+	 if (sep)
+	 {
+	    char *p;
+	    int eq = 0, gt = 0, lt = 0;
+
+	    VerIsRel = false;
+	    for (p = sep; *p && strchr("=><",*p); ++p)
+	       switch (*p)
+	       {
+		  case '=': eq = 1; break;
+		  case '>': gt = 1; break;
+		  case '<': lt = 1; break;
+	       }
+	    if (eq)
+	    {
+	       if (lt && gt)
+		  return _error->Error(_("Couldn't parse name '%s'"),S);
+	       else if (lt)
+		  VerOp = pkgCache::Dep::LessEq;
+	       else if (gt)
+		  VerOp = pkgCache::Dep::GreaterEq;
+	       else
+		  VerOp = pkgCache::Dep::Equals;
+	    }
+	    else
+	    {
+	       if (lt && gt)
+		  VerOp = pkgCache::Dep::NotEquals;
+	       else if (lt)
+		  VerOp = pkgCache::Dep::Less;
+	       else if (gt)
+		  VerOp = pkgCache::Dep::Greater;
+	       else
+		  return _error->Error(_("Couldn't parse name '%s'"),S);
+	    }
+	    *sep = '\0';
+	    /* S may be overwritten later, for example, if it contains
+	     * a file name that will be resolved to a package.
+	     * So we point VerTag to the same offset in OrigS. */
+	    VerTag = (p - S) + OrigS;
+	 }
+	 
+	 // CNC:2003-11-21 - Try to handle unknown file items.
+	 if (S[0] == '/')
+	 {
+	    pkgRecords Recs(Cache);
+	    if (_error->PendingError() == true)
+	       return false;
+	    pkgCache::PkgIterator Pkg = (*Cache).PkgBegin();
+	    for (; Pkg.end() == false; Pkg++)
+	    {
+	       // Should we try on all versions?
+	       pkgCache::VerIterator Ver = (*Cache)[Pkg].CandidateVerIter(*Cache);
+	       if (Ver.end() == false)
+	       {
+		  pkgRecords::Parser &Parse = Recs.Lookup(Ver.FileList());
+		  if (Parse.HasFile(S)) {
+		     strcpy(S, Pkg.Name());
+		     ioprintf(c1out,_("Selecting %s for '%s'\n"),
+			      Pkg.Name(),OrigS);
+		     // Confirm the translation.
+		     ExpectedInst += 1000;
+		     break;
+		  }
+	       }
+	    }
+	 }
+
+	 char *Slash = strchr(S,'/');
+	 if (Slash != 0)
+	 {
+	    VerIsRel = true;
+	    *Slash = 0;
+	    VerTag = Slash + 1;
+	 }
+	 
+	 break;
+      }
+      
+      // Locate the package
+      pkgCache::PkgIterator Pkg = Cache->FindPkg(S);
+      Packages++;
+      if (Pkg.end() == true)
+      {
+	 // Check if the name is a regex
+	 const char *I;
+	 for (I = S; *I != 0; I++)
+	    if (*I == '?' || *I == '*' || *I == '|' ||
+	        *I == '[' || *I == '^' || *I == '$')
+	       break;
+
+	 // CNC:2003-05-15
+	 if (*I == 0) {
+#ifdef APT_WITH_LUA
+	    vector<string> VS;
+	    _lua->SetDepCache(Cache);
+	    _lua->SetDontFix();
+	    _lua->SetGlobal("argument", OrigS);
+	    _lua->SetGlobal("translated", VS);
+	    _lua->RunScripts("Scripts::AptGet::Install::TranslateArg");
+	    const char *name = _lua->GetGlobalStr("translated");
+	    if (name != NULL) {
+	       VS.push_back(name);
+	    } else {
+	       VS = _lua->GetGlobalStrList("translated");
+	    }
+	    _lua->ResetGlobals();
+	    _lua->ResetCaches();
+
+	    // Translations must always be confirmed
+	    ExpectedInst += 1000;
+
+	    // Run over the matches
+	    bool Hit = false;
+	    for (vector<string>::const_iterator I = VS.begin();
+	         I != VS.end(); I++) {
+
+	       Pkg = Cache->FindPkg(*I);
+	       if (Pkg.end() == true)
+		  continue;
+
+	       ioprintf(c1out,_("Selecting %s for '%s'\n"),
+			Pkg.Name(),OrigS);
+	    
+	       Hit |= TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,
+				   ExpectedInst,true);
+	    }
+	 
+	    if (Hit == true)
+	       continue;
+#endif
+	    return _error->Error(_("Couldn't find package %s"),S);
+	 }
+
+	 // Regexs must always be confirmed
+	 ExpectedInst += 1000;
+	 
+	 // Compile the regex pattern
+	 regex_t Pattern;
+	 int Res;
+	 if ((Res = regcomp(&Pattern,S,REG_EXTENDED | REG_ICASE |
+		     REG_NOSUB)) != 0)
+	 {
+	    char Error[300];	    
+	    regerror(Res,&Pattern,Error,sizeof(Error));
+	    return _error->Error(_("Regex compilation error - %s"),Error);
+	 }
+	 
+	 // Run over the matches
+	 bool Hit = false;
+	 for (Pkg = Cache->PkgBegin(); Pkg.end() == false; Pkg++)
+	 {
+	    if (regexec(&Pattern,Pkg.Name(),0,0,0) != 0)
+	       continue;
+	    
+	    // CNC:2003-11-23
+	    ioprintf(c1out,_("Selecting %s for '%s'\n"),
+		     Pkg.Name(),S);
+	    
+	    if (VerTag != 0)
+	       // CNC:2003-11-05
+	       if (TryToChangeVer(Pkg,Cache,VerOp,VerTag,VerIsRel) == false)
+		  return false;
+	    
+	    Hit |= TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,
+				ExpectedInst,false);
+	 }
+	 regfree(&Pattern);
+	 
+	 if (Hit == false)
+	    return _error->Error(_("Couldn't find package %s"),S);
+      }
+      else
+      {
+#ifdef APT_RPM_DEBUG
+         std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << " " << Pkg.Name() << " " << Pkg->CurrentVer << std::endl;
+#endif
+         // FIXME: why CurrentVer is zero?! TryToInstall will consider it 
+         // (CurrentVer == 0) is not installed package! so just use rpm command 
+         // dirtly...
+         if (Remove) {
+            std::string cmd = std::string("rpm --isoftapp -e ") + Pkg.Name();
+            system(cmd.c_str());
+            return true;
+         }
+	 if (VerTag != 0)
+	    // CNC:2003-11-05
+	    if (TryToChangeVer(Pkg,Cache,VerOp,VerTag,VerIsRel) == false)
+	       return false;
+	 if (TryToInstall(Pkg,Cache,Fix,Remove,BrokenFix,ExpectedInst) == false)
+	    return false;
+      }      
+   }
+
+// CNC:2003-03-19
+#ifdef APT_WITH_LUA
+   _lua->SetDepCache(Cache);
+   _lua->SetDontFix();
+   _lua->RunScripts("Scripts::AptGet::Install::PreResolve");
+   _lua->ResetCaches();
+#endif
+
+   // CNC:2002-08-01
+   if (_config->FindB("APT::Remove-Depends",false) == true)
+      Fix.RemoveDepends();
+
+   /* If we are in the Broken fixing mode we do not attempt to fix the
+      problems. This is if the user invoked install without -f and gave
+      packages */
+   if (BrokenFix == true && Cache->BrokenCount() != 0)
+   {
+      c1out << _("You might want to run `apt-get --fix-broken install' to correct these:") << endl;
+      ShowBroken(c1out,Cache,false);
+
+      return _error->Error(_("Unmet dependencies. Try 'apt-get --fix-broken install' with no packages (or specify a solution)."));
+   }
+   
+   // Call the scored problem resolver
+   Fix.InstallProtect();
+   if (Fix.Resolve(true) == false)
+      _error->Discard();
+
+// CNC:2003-03-19
+#ifdef APT_WITH_LUA
+   if (Cache->BrokenCount() == 0) {
+      _lua->SetDepCache(Cache);
+      _lua->SetProblemResolver(&Fix);
+      _lua->RunScripts("Scripts::AptGet::Install::PostResolve");
+      _lua->ResetCaches();
+   }
+#endif
+
+   // Now we check the state of the packages,
+   if (Cache->BrokenCount() != 0)
+   {
+      c1out << 
+       _("Some packages could not be installed. This may mean that you have\n" 
+	 "requested an impossible situation or that some of the repositories\n"
+	 "in use are in an inconsistent state at the moment.") << endl;
+      if (Packages == 1)
+      {
+	 c1out << endl;
+	 c1out << 
+	  _("Since you only requested a single operation it is extremely likely that\n"
+	    "the package is simply not installable and a bug report against\n" 
+	    "that package should be filed.") << endl;
+      }
+
+      c1out << _("The following information may help to resolve the situation:") << endl;
+      c1out << endl;
+      ShowBroken(c1out,Cache,false);
+
+      return _error->Error(_("Broken packages"));
+
+   }   
+   
+   /* Print out a list of packages that are going to be installed extra
+      to what the user asked */
+   if (Cache->InstCount() != ExpectedInst)
+   {
+      string List;
+      string VersionsList;
+      for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+      {
+	 pkgCache::PkgIterator I(Cache,Cache.List[J]);
+	 if ((*Cache)[I].Install() == false)
+	    continue;
+
+	 // CNC:2004-06-15
+	 const char **K;
+	 for (K = CmdL.FileList + 1; *K != 0; K++)
+	    if (strcmp(*K,I.Name()) == 0)
+		break;
+	 
+	 if (*K == 0) {
+	    List += string(I.Name()) + " ";
+        VersionsList += string(Cache[I].CandVersion) + "\n";
+     }
+      }
+      
+      ShowList(c1out,_("The following extra packages will be installed:"),List,VersionsList);
+   }
+
+   /* Print out a list of suggested and recommended packages */
+   {
+      string SuggestsList, RecommendsList, List;
+      string SuggestsVersions, RecommendsVersions;
+      for (unsigned J = 0; J < Cache->Head().PackageCount; J++)
+      {
+	 pkgCache::PkgIterator I(Cache,Cache.List[J]);
+
+	 /* Just look at the ones we want to install */
+	 if ((*Cache)[I].Install() == false)
+	   continue;
+
+	 for (pkgCache::VerIterator V = I.VersionList(); V.end() == false; V++)
+	   {
+	     for (pkgCache::DepIterator D = V.DependsList(); D.end() == false; D++)
+	       {
+		 pkgCache::DepIterator Start;
+		 pkgCache::DepIterator End;
+		 D.GlobOr(Start,End);
+
+		 /* 
+		  * If this is a virtual package, we need to check the list of
+		  * packages that provide it and see if any of those are
+		  * installed
+		  */
+		 pkgCache::PrvIterator Prv = Start.TargetPkg().ProvidesList();
+		 bool providedBySomething = false;
+		 for (; Prv.end() != true; Prv++)
+		    if ((*Cache)[Prv.OwnerPkg()].InstVerIter(*Cache).end() == false) {
+		       providedBySomething = true;
+		       break;
+		    }
+
+		 if (providedBySomething) continue;
+            
+		 do
+		   {
+		     if (Start->Type == pkgCache::Dep::Suggests) {
+
+		       /* A suggests relations, let's see if we have it 
+			  installed already */
+
+		       string target = string(Start.TargetPkg().Name()) + " ";
+		       if ((*Start.TargetPkg()).SelectedState == pkgCache::State::Install || Cache[Start.TargetPkg()].Install())
+			 break;
+		       /* Does another package suggest it as well?  If so,
+			  don't print it twice */
+		       if (int(SuggestsList.find(target)) > -1)
+			 break; 
+		       SuggestsList += target;
+		       SuggestsVersions += string(Cache[Start.TargetPkg()].CandVersion) + "\n";
+		     }
+		     
+		     if (Start->Type == pkgCache::Dep::Recommends) {
+
+		       /* A recommends relation, let's see if we have it
+			  installed already */
+
+		       string target = string(Start.TargetPkg().Name()) + " ";
+		       if ((*Start.TargetPkg()).SelectedState == pkgCache::State::Install || Cache[Start.TargetPkg()].Install())
+			 break;
+		       
+		       /* Does another package recommend it as well?  If so,
+			  don't print it twice */
+
+		       if (int(RecommendsList.find(target)) > -1)
+			 break;
+		       RecommendsList += target;
+		       SuggestsVersions += string(Cache[Start.TargetPkg()].CandVersion) + "\n";
+		     }
+	      if (Start == End)
+		break;
+	      Start++;
+	    } while (1);
+	       }
+	   }
+      }
+      ShowList(c1out,_("Suggested packages:"),SuggestsList,SuggestsVersions);
+      ShowList(c1out,_("Recommended packages:"),RecommendsList,RecommendsVersions);
+
+   }
+
+   // CNC:2003-03-06
+   if (CheckOnly(Cache) == true)
+      return true;
+
+   // See if we need to prompt
+   if (Cache->InstCount() == ExpectedInst && Cache->DelCount() == 0)
+      return InstallPackages(Cache,false,false);
+   
+   return InstallPackages(Cache,false);   
+}
+   // #############################end xxxxxx#######################################
+
+
 // DoInstall - Install packages from the command line			/*{{{*/
 // ---------------------------------------------------------------------
 /* Install named packages */
 bool DoInstall(CommandLine &CmdL)
 {
    CacheFile Cache;
+   char pkgName[512]="";
    if (Cache.OpenForInstall() == false || 
        Cache.CheckDeps(CmdL.FileSize() != 1) == false)
       return false;
@@ -1112,6 +1567,8 @@ bool DoInstall(CommandLine &CmdL)
       // CNC:2003-03-15
       char OrigS[300];
       strcpy(OrigS,S);
+
+      snprintf(pkgName,sizeof(pkgName), "%s",S);
       
       // See if we are removing and special indicators..
       bool Remove = DefRemove;
@@ -1312,6 +1769,17 @@ bool DoInstall(CommandLine &CmdL)
       }
       else
       {
+#ifdef APT_RPM_DEBUG
+         std::cout << "DEBUG: " << __FILE__ << " " << __PRETTY_FUNCTION__ << " " << __LINE__ << " " << Pkg.Name() << " " << Pkg->CurrentVer << std::endl;
+#endif
+         // FIXME: why CurrentVer is zero?! TryToInstall will consider it 
+         // (CurrentVer == 0) is not installed package! so just use rpm command 
+         // dirtly...
+         if (Remove) {
+            std::string cmd = std::string("rpm --isoftapp -e ") + Pkg.Name();
+            system(cmd.c_str());
+            return true;
+         }
 	 if (VerTag != 0)
 	    // CNC:2003-11-05
 	    if (TryToChangeVer(Pkg,Cache,VerOp,VerTag,VerIsRel) == false)
@@ -1378,7 +1846,17 @@ bool DoInstall(CommandLine &CmdL)
       c1out << _("The following information may help to resolve the situation:") << endl;
       c1out << endl;
       ShowBroken(c1out,Cache,false);
+
+      // TODO: try to check isoftapp
+      #ifdef USEISOFTAPP 
+      Cache.Close();
+      c1out << endl;
+      c1out << _("Try to check isoft app db:") << endl;
+      c1out << endl;
+      return tryNewCache(pkgName,CmdL);
+      #else
       return _error->Error(_("Broken packages"));
+      #endif
    }   
    
    /* Print out a list of packages that are going to be installed extra
diff --git a/cmdline/cmdline.cc b/cmdline/cmdline.cc
index 59bf011..fc60ed7 100644
--- a/cmdline/cmdline.cc
+++ b/cmdline/cmdline.cc
@@ -189,7 +189,7 @@ int cmdCacheFile::NameComp(const void *a,const void *b)
 /* */
 void cmdCacheFile::Sort()
 {
-   delete [] List;
+   //delete [] List;
    List = new pkgCache::Package *[Cache->Head().PackageCount];
    memset(List,0,sizeof(*List)*Cache->Head().PackageCount);
    pkgCache::PkgIterator I = Cache->PkgBegin();
@@ -204,6 +204,7 @@ cmdCacheFile::~cmdCacheFile()
 {
    if (List) {
       delete [] List;
+      List = NULL;
    }
 }
 
diff --git a/cmdline/cmdline.h b/cmdline/cmdline.h
index 4bacf8c..5c662ee 100644
--- a/cmdline/cmdline.h
+++ b/cmdline/cmdline.h
@@ -36,7 +36,8 @@ class cmdCacheFile : public pkgCacheFile
    pkgCache::Package **List;
    void Sort();
 
-   cmdCacheFile() : List(0) {}
+   //cmdCacheFile() : List(0) {}
+   cmdCacheFile(bool useIsoft = false) : pkgCacheFile(useIsoft) {}
    virtual ~cmdCacheFile();
 };
 
